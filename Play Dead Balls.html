
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dead Balls</title>
<style>
  html, body { margin:0; padding:0; background:#111; color:#eee; font-family:system-ui, sans-serif; }
  #ui { position:fixed; left:10px; top:10px; z-index:10; }
  .row { margin-bottom:6px; }
  #game { display:block; margin:12px auto; border:2px solid #444; background:#1a1a1a; }
  .help-panel {
    padding:8px;
    margin-top:8px;
    font-size:12px;
    max-width:260px;
  }

  .help-panel ul {
    padding-left:16px;
    margin:4px 0 0 0;
  }

  .help-panel hr {
    border-color:#444;
    margin:6px 0;
  }

  .badge { display:inline-block; padding:2px 6px; margin-right:6px; border:1px solid #666; border-radius:4px; }
  .power { margin-top:4px; font-size:12px; color:#ddd; }
  #menu {
    position:fixed;
    inset:0;
    background:#111;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:999;
    }

  #menu h1 {
    margin-bottom:20px;
  }

  #menu button {
    padding:10px 20px;
    font-size:18px;
    cursor:pointer;
  }

  .round-ui {
    font-size: 14px;
    letter-spacing: 2px;
    color: #aaa;
  }

  .round-number {
   display: inline-block;
    margin-left: 6px;
    font-size: 42px;          
    font-weight: 900;
    color: #e74c3c;           
    text-shadow:
      0 0 6px rgba(231, 76, 60, 0.8),
      0 0 12px rgba(0, 0, 0, 0.8);
  }

  .zombie-ui {
    margin-top: 4px;
   font-size: 14px;
    letter-spacing: 2px;
    color: #aaa;
  }

  .zombie-number {
    display: inline-block;
    margin-left: 6px;
    font-size: 14px;      
    font-weight: 700;
    color: #f1c40f;       
  }




</style>
</head>
<body>
  <script src="scripts/player_info.js"></script>
  <script src="scripts/player_stats.js"></script>


<div id="ui">
  <div class="row round-ui">
    ROUND
    <span id="round" class="round-number">1</span>
  </div>

  <div class="row round-ui zombie-ui">
    ZOMBIES LEFT
    <span id="zombiesLeft" class="zombie-number">0</span>
  </div>



  <div id="gameOver" style="
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.85);
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:1000;
    color:white;
    text-align:center;
  ">
    <h1 style="font-size:64px;margin-bottom:20px;">GAME OVER</h1>


    <div>F5 - Back to Main Menu / Reload game</div>

    <button id="restartBtn" style="
      padding:14px 28px;
      font-size:22px;
      cursor:pointer;
    ">
      Restart Game
    </button>

    <div class="row" style="margin-top:8px;">
      LVL <span id="uiLevel">1</span>
      <div style="width:160px;height:8px;background:#333;border-radius:6px;margin-top:4px;">
        <div id="uiExpBar" style="height:100%;width:0%;background:#3498db;border-radius:6px;"></div>
      </div>
    </div>
  </div>


</div>
<div id="menu">
  <h1>üßü Dead Balls</h1>

  <input type="file" id="mapLoader" accept=".json">
  <br><br>

  <button id="startBtn" disabled>Start Game</button>

  <p id="mapName">No map loaded</p>

  <div id="menuLevel" style="margin-bottom:14px;text-align:center;">
  <div style="font-size:18px;font-weight:700;">
    LEVEL <span id="menuLevelNum">1</span>
  </div>
  <div style="width:220px;height:10px;background:#333;border-radius:6px;margin-top:6px;">
    <div id="menuExpBar" style="height:100%;width:0%;background:#2ecc71;border-radius:6px;"></div>
  </div>
</div>

<button
  id="resetProgressBtn"
  style="
    margin-top:12px;
    padding:8px 16px;
    font-size:14px;
    font-weight:700;
    cursor:pointer;
    background:#8b0000;
    color:white;
    border:2px solid white;
  "
>
  RESET PROGRESS
</button>


<button
  id="mapEditorBtn"
  style="
    margin-top:12px;
    padding:10px 20px;
    font-size:16px;
    font-weight:700;
    cursor:pointer;
    background:#2c3e50;
    color:white;
    border:2px solid white;
  "
>
  üõ† Open Map Editor
</button>



</div>

<canvas id="game"></canvas>


<div id="mysteryBoxDisplay" style="
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  padding: 16px 28px;
  background: rgba(0,0,0,0.85);
  border: 3px solid gold;
  border-radius: 12px;
  font-size: 26px;
  font-weight: bold;
  color: gold;
  display: none;
  pointer-events: none;
  z-index: 9999;
">
  ?
</div>






<script src="scripts/guns.js"></script>
<script src="scripts/gun_sounds.js"></script>
<script src="scripts/powerup_sounds.js"></script>



<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvasToScreen() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    camera.w = canvas.width;
    camera.h = canvas.height;
  }



  // resize once on load
  function resizeCanvasToScreen() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }


  // resize when browser window changes
  window.addEventListener('resize', resizeCanvasToScreen);


  // UI elements
  const uiRound = document.getElementById('round');
  const uiPoints = document.getElementById('points');
  const uiHealth = document.getElementById('health');
  const uiHealthMax = document.getElementById('healthMax');
  const uiWeapon = document.getElementById('weapon');
  const uiAmmo = document.getElementById('ammo');
  const uiPowers = document.getElementById('powers');
  const uiPerks = document.getElementById('perks');
  const uiZombiesLeft = document.getElementById('zombiesLeft');
  
  
  const restartBtn = document.getElementById('restartBtn');

  if (restartBtn) {
    restartBtn.onclick = () => {
      restartGame();
      PlayerStats.reset();
    };
  }





  let LOADED_MAP = null;
  let gameStarted = false;
  let WIDTH = canvas.width;
  let HEIGHT = canvas.height;
  let WORLD_WIDTH = WIDTH;
  let WORLD_HEIGHT = HEIGHT;
  let gamePaused = false;
  let musicVolume = 0.5;
  window._musicTracks = [];


  // ONLY set defaults if no map is loaded
    if (!LOADED_MAP) {
      WORLD_WIDTH = WIDTH;
      WORLD_HEIGHT = HEIGHT;
    }


  let roundBannerStart = 0;
  const ROUND_BANNER_DURATION = 2000; // ms

  
  

  const menu = document.getElementById('menu');
  const mapLoader = document.getElementById('mapLoader');
  const startBtn = document.getElementById('startBtn');
  const mapNameText = document.getElementById('mapName');

  mapLoader.addEventListener('change', () => {
    const file = mapLoader.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        LOADED_MAP = JSON.parse(reader.result);
        mapNameText.textContent = `Loaded: ${file.name}`;
        startBtn.disabled = false;
      } catch {
        alert("Invalid map file");
      }
    };
    reader.readAsText(file);
  });

  startBtn.onclick = () => {
    zombies.length = 0;
    bullets.length = 0;
    loadMap(LOADED_MAP);
    menu.style.display = 'none';

    gameStarted = true;
    round = 1;
    startRoundSpawns();
    MusicPlayer.play();
  };



  function drawWorldBorder() {
    ctx.save();

    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 4 / camera.zoom; // consistent thickness
    ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    ctx.restore();
  }



const resetBtn = document.getElementById('resetProgressBtn');

if (resetBtn) {
  resetBtn.addEventListener('click', () => {
    const confirmReset = confirm(
      'Are you sure you want to reset your level and EXP?\nThis cannot be undone.'
    );

    if (!confirmReset) return;

    PlayerInfo.reset();
  });
}


  // ===== GLOBAL GAME ARRAYS (MUST BE ABOVE loadMap) =====
  const zombies = [];
  const bullets = [];
  const barriers = [];
  const zombieSpawns = [];
  const bossSpawns = [];
  const walls = [];
  const mysteryBoxes = [];
  const perkMachines = [];
  const upgradeStations = [];
  const wallBuys = [];
  const interacts = [];
  const powerDrops = [];
  const SHOW_WORLD_BORDER = true;
  const doors = [];
  const ZOMBIE_STUCK_TIME = 15;     // seconds before considered stuck
  const ZOMBIE_STUCK_DIST = 2;      // px movement threshold
  const ZOMBIE_TELEPORT_RADIUS = 10 * 10; // 25 blocks √ó 20px grid
  const POWER_DROP_CHANCE = 1 / 123; // ‚âà 0.00813
  const grenades = [];
  const GRENADE_THROW_FORCE = 420;     // forward velocity
  const GRENADE_UP_FORCE = 220;        // arc height
  const GRENADE_FUSE = 1500;           // ms
  const GRENADE_RADIUS = 5 * 20;      // 10 blocks (20px grid)
  const GRENADE_THROW_DISTANCE = 6 * 20; // 6 blocks
  const GRENADE_FUSE_TIME = 3000;
  const grenadeExplosions = [];

  const MONKEY_ATTRACT_TIME = 4000;   // how long zombies are attracted (ms)
  const MONKEY_EXPLODE_TIME = 5500;   // total lifetime until explosion
  const MONKEY_RADIUS = 100;          // BIGGER explosion radius

  // ==== BOSS ZOMBIE SYSTEM ====
let nextBossRound = Math.floor(Math.random() * 3) + 5;
let bossZombiesRemaining = 0;
let lastBossPosition = { x: 0, y: 0 };

const BOSS_CONFIG = {
  minSpawn: 5,
  maxSpawn: 10,
  sizeMultiplier: 1.8,
  speedMultiplier: 1.0,
  healthMultiplier: 5,
  damageMultiplier: 3,
  roundInterval: { min: 5, max: 7 }
};



  

  const playerStats = {
  kills: 0,
  weaponUpgrades: 0,
  downs: 0,
  points: 0,
  doorsOpened: 0
};


  // ===== MYSTERY BOX SYSTEM =====
  let activeMysteryIndex = -1;
  let mysterySpinCount = 0;
  window.MASTER_VOLUME = window.MASTER_VOLUME ?? 0.6;
  window.musicVolume = window.musicVolume ?? 0.10;
  window.powerupVolume = 0.60;
  window.roundChangeVolume = window.roundChangeVolume ?? 0.6;

  

  const INTERACT_COOLDOWN_MS = 2000;

  let lastGlobalInteractTime = 0;

  function canInteractNow() {
    return performance.now() - lastGlobalInteractTime >= INTERACT_COOLDOWN_MS;
  }

  function markInteractUsed() {
    lastGlobalInteractTime = performance.now();
  }


  const MYSTERY_MOVE_SPINS = 10;
  const MYSTERY_MOVE_CHANCE = 0.45;
  const zombieTraps = [];
  const musicSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};

const masterSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};
const powerupSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};

const roundChangeSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};
  

  const PLAYER_DEFAULTS = {
    speed: 115,
    hitsMax: 4,
   reviveDuration: 4.21
  };


  // ===== POWER-UP ICONS =====
  const powerIcons = {
    insta: new Image(),
    double: new Image(),
    nuke: new Image(),
    max: new Image(),
    carpenter: new Image(),
    death: new Image()
  };

  // üîÅ replace paths with your custom PNGs
  powerIcons.insta.src = 'assets/powerups/insta.png';
  powerIcons.double.src = 'assets/powerups/2x.png';
  powerIcons.nuke.src = 'assets/powerups/nuke.png';
  powerIcons.max.src = 'assets/powerups/max.png';
  powerIcons.carpenter.src = 'assets/powerups/carpenter.png';
  powerIcons.death.src = 'assets/powerups/death.png';


  // ===== PERK ICONS =====
  const perkIcons = {
    juggernog: new Image(),
    speedCola: new Image(),
    doubleTap: new Image(),
    staminUp: new Image(),
    quickRevive: new Image()
  };

  perkIcons.juggernog.src = 'assets/perks/juggernog.png';
  perkIcons.speedCola.src = 'assets/perks/speedCola.png';
  perkIcons.doubleTap.src = 'assets/perks/doubleTap.png';
  perkIcons.staminUp.src = 'assets/perks/staminUp.png';
  perkIcons.quickRevive.src = 'assets/perks/quickRevive.png';


  const perkColors = {
    juggernog:  '#e74c3c', 
    speedCola:  '#3498db', 
    doubleTap:  '#f1c40f', 
    staminUp:   '#f57242', 
    quickRevive:'#1abc9c'  
  };


  // ===== ZOMBIE DROP RARITIES =====
  const DROP_RARITIES = {
    common: {
      chance: 0.35,
      drops: ['2X', 'CARPENTER']
    },
    rare: {
      chance: 0.15,
      drops: ['INSTA', 'MAX']
    },
    legendary: {
      chance: 0.05,
      drops: ['NUKE', 'DEATH']
    }
  };

const mapEditorBtn = document.getElementById('mapEditorBtn');

mapEditorBtn.onclick = () => {
  // open editor in a new tab
  window.open('scripts/map_editor.html', '_blank');
};


window.updatePlayerExpUI = function () {
  const pct = Math.min(
    100,
    (PlayerInfo.exp / PlayerInfo.expToNext) * 100
  );

  // ===== MENU UI =====
  const menuLevelNum = document.getElementById('menuLevelNum');
  const menuExpBar = document.getElementById('menuExpBar');

  if (menuLevelNum) menuLevelNum.textContent = PlayerInfo.level;
  if (menuExpBar) menuExpBar.style.width = pct + '%';

  // ===== IN-GAME UI =====
  const uiLevel = document.getElementById('uiLevel');
  const uiExpBar = document.getElementById('uiExpBar');

  if (uiLevel) uiLevel.textContent = PlayerInfo.level;
  if (uiExpBar) uiExpBar.style.width = pct + '%';
};

updatePlayerExpUI();




window.setMasterVolume = v => {
  MASTER_VOLUME = Math.max(0, Math.min(1, v));
};

window.setRoundChangeVolume = v => {
  window.roundChangeVolume = Math.max(0, Math.min(1, v));

  // üî• APPLY IMMEDIATELY
  if (window.RoundMusic) {
    RoundMusic.applyVolume();
  }
};


window.setMusicVolume = v => {
  window.musicVolume = Math.max(0, Math.min(1, v));

  // apply to ALL registered music
  for (const track of window._musicTracks) {
    if (!track) continue;
    track.volume = window.musicVolume;
  }
};

// ===== ACTIVE MUSIC TRACK =====
window.currentMusic = null;

window.musicVolume = window.musicVolume ?? 0.6;

window.setMusicVolume = function (v) {
  window.musicVolume = Math.max(0, Math.min(1, v));

  // APPLY IMMEDIATELY
  if (window.currentMusic) {
    window.currentMusic.volume =
      window.musicVolume * (window.MASTER_VOLUME ?? 1);
  }
};

  

  // ===== CAMERA =====
  const camera = {
      x: 0,
      y: 0,
      zoom: 1.3,
      w: window.innerWidth,
      h: window.innerHeight
    };

    // ‚úÖ FIRST SAFE CALL
    resizeCanvasToScreen();
    camera.w = canvas.width;
    camera.h = canvas.height;

    // ‚úÖ SAFE resize listener
    window.addEventListener('resize', () => {
      resizeCanvasToScreen();
      camera.w = canvas.width;
      camera.h = canvas.height;
    })

    resizeCanvasToScreen();



    function clampPlayerToWorld() {
      player.x = clamp(player.x, player.radius, WORLD_WIDTH - player.radius);
      player.y = clamp(player.y, player.radius, WORLD_HEIGHT - player.radius);
    }

    function isSpawnUnlocked(spawn) {
      // No door link = always active
      if (!spawn.linkedDoorId) return true;

      const door = doors.find(d => d.id === spawn.linkedDoorId);
      if (!door) return true; // safety fallback

      return door.open === true;
    }

    function openDoorAndLinked(door) {
  if (!door) return;

  const group = door.linkGroup || null;

  for (const d of doors) {
    if (d === door || (group && d.linkGroup === group)) {
      d.open = true;

      // üî• HARD-disable interaction
      d.cost = 0;
      d._disabled = true; // optional safety flag
    }
  }
}


  

  window.loadMap = function(map) {
    console.log("LOADING MAP", map);
    



  // Map size
    if (map.width && map.height) {
        WORLD_WIDTH = map.width;
        WORLD_HEIGHT = map.height;
      }


    doors.length = 0;

    if (Array.isArray(map.doors)) {
      map.doors.forEach(d => {
        doors.push({
          id: d.id,
          x: d.x,
          y: d.y,
          w: d.w,
          h: d.h,
          rotation: d.rotation || 0,
          cost: d.cost,
          linkGroup: d.linkGroup || null,
          open: false
        });

      });
    }




  // Reset barriers AFTER creation
    for (const b of barriers) {
      b.hpMax = b.hpMax ?? 100;
      b.hp = b.hpMax;
      b.open = false;
    }


  // Clear existing data
    barriers.length = 0;
    perkMachines.length = 0;
    wallBuys.length = 0;
    mysteryBoxes.length = 0;
    upgradeStations.length = 0;
    zombieSpawns.length = 0;
    interacts.length = 0;
    zombieTraps.length = 0;

    if (map.spawns && map.spawns.length > 0) {
      player.x = map.spawns[0].x;
      player.y = map.spawns[0].y;
    }

    



    /* ---------- WALLS (CENTER ‚Üí TOP-LEFT FIX) ---------- */
    /* ---------- WALLS (CENTER-BASED) ---------- */
    walls.length = 0;

    if (Array.isArray(map.walls)) {
      map.walls.forEach(w => {
        walls.push({
          x: w.x,
          y: w.y,
          w: w.w,
          h: w.h,
          rotation: w.rotation || 0,
          slope: w.slope || null,
          flip: w.flip === true  
        });
      });
    }
      doors.forEach(d => {
        if (!d.open) {
          resolveCircleWallCollision(player, d);
          zombies.forEach(z => resolveCircleWallCollision(z, d));
        }
      });


  /* ---------- BARRIERS (CENTER ‚Üí TOP-LEFT FIX) ---------- */
    if (Array.isArray(map.barriers)) {
      map.barriers.forEach(b => {
        barriers.push({
          // convert center-based to top-left
          x: b.x - b.w / 2,
          y: b.y - b.h / 2,
          w: b.w,
          h: b.h,

          rotation: b.rotation || 0, // keep for future
          hpMax: 100,
          hp: 100,
          open: false
        });
      });
    }



    

    // ---------- PLAYER SPAWN ----------
    if (Array.isArray(map.playerSpawns) && map.playerSpawns.length > 0) {
      const s = map.playerSpawns[Math.floor(Math.random() * map.playerSpawns.length)];
      player.x = s.x;
      player.y = s.y;
    } else {
      // fallback
      player.x = WORLD_WIDTH / 2;
      player.y = WORLD_HEIGHT / 2;
    }

  /* ---------- INTERACTABLES ---------- */
    if (Array.isArray(map.interacts)) {
      map.interacts.forEach(obj => {




        if (obj.type === 'perk') {
          perkMachines.push({
            x: obj.x,
            y: obj.y,
            perk: obj.perk,
            cost: obj.cost
          });
        }

        else if (obj.type === 'wallbuy') {
          wallBuys.push({
            x: obj.x,
            y: obj.y,
            gun: obj.gun,
            cost: obj.cost
          });
        }

        else if (obj.type === 'mystery') {
          mysteryBoxes.push({
            x: obj.x,
            y: obj.y,
            cost: obj.cost
          });
        }

        else if (obj.type === 'upgrade') {
          upgradeStations.push({
            x: obj.x,
            y: obj.y,
            cost: obj.cost
          });
        }

        else if (obj.type === 'trap') {
          zombieTraps.push({
            x: obj.x,
            y: obj.y,
            w: obj.w,
            h: obj.h,
            cost: obj.cost,
            duration: obj.duration ?? 10,
            cooldown: obj.cooldown ?? 10,

            // üî• RUNTIME STATE (MUST LIVE HERE)
            active: false,
            pending: false,
            activateAt: 0,
            activeUntil: 0,
            cooldownUntil: 0
          });

        }


        else {
          console.warn("Unknown interact type:", obj);
        }
      });
    }
function withInteractCooldown(action) {
  return () => {
    if (!canInteractNow()) return;
    action();
    markInteractUsed();
  };
}

    //------------------
    // Rebuild interact list (used by draw() and E key)
    for (const p of perkMachines) {
      interacts.push({
        type: 'perk',
        x: p.x,
        y: p.y,
        perk: p.perk,
        cost: p.cost,
        label: () => `${p.perk} (${p.cost})`,
        action: () => tryBuyPerk(p.perk, p.cost)


      });
    }


  for (const w of wallBuys) {
    interacts.push({
      type: 'wall',
      x: w.x,
      y: w.y,
      gunName: w.gun,
      cost: w.cost,
      label: `Buy ${w.gun} (${w.cost})`,
      action: () => {
        const gunKey = w.gun.trim().toUpperCase();
        const gun = WALL_BUY_GUNS[gunKey];

        if (!gun) {
          console.warn("Invalid wall-buy gun:", w.gun);
          return;
        }

        tryBuyAmmoOrGun(gun, w.cost);
      }


    });
  }

  for (const m of mysteryBoxes) {
    interacts.push({
      type: 'box',
      x: m.x,
      y: m.y,
      cost: m.cost,
      label: () =>
        m.active
          ? `Mystery Box (${m.cost})`
          : `Inactive Mystery Box`,
      action: () => {
        if (!m.active) return;
        tryMysteryBox(m.cost);
      },
      ref: m // üîë keep reference
    });
  }


  for (const d of doors) {
  // ‚ùå Never create an interact for an open door
  if (d.open) continue;

  // ‚ùå Never create an interact if this door is linked
  // and ANY door in its group is open
  if (d.linkGroup) {
    let groupIsOpen = false;

    for (const od of doors) {
      if (od.linkGroup === d.linkGroup && od.open) {
        groupIsOpen = true;
        break;
      }
    }

    if (groupIsOpen) continue;
  }

  interacts.push({
    type: 'door',
    x: d.x,
    y: d.y,
    cost: d.cost,
    label: `Open Door (${d.cost})`,
    action: () => tryBuyDoor(d)
  });
}




  for (const u of upgradeStations) {
    interacts.push({
      type: 'upgrade',
      x: u.x,
      y: u.y,
      r: 48, // ‚úÖ REQUIRED for E key detection
      cost: u.cost,
      label: () => {
        const g = player.currentGun;
        if (!g) return 'Upgrade Weapon';
        return `Upgrade ${g.name} (${u.cost})`;
      },
      action: () => tryUpgradeCurrentGun(u.cost)
    });
  }


    // ---------- ZOMBIE TRAP INTERACTS ----------
    // ---------- ZOMBIE TRAP INTERACTS ----------
    for (const t of zombieTraps) {

      // ‚úÖ SAFETY INIT (VERY IMPORTANT)
      if (t.cooldownUntil == null) t.cooldownUntil = 0;
      if (t.activeUntil == null) t.activeUntil = 0;
      if (t.activateAt == null) t.activateAt = 0;
      if (t.pending == null) t.pending = false;
      if (t.active == null) t.active = false;

      interacts.push({
        x: t.x,
        y: t.y,
        r: 48,

        label() {
          const now = performance.now();

          if (t.active) return 'Trap Active';
          if (t.pending) return 'Activating...';
          if (now < t.cooldownUntil) return 'Cooling Down...';

          return `Activate Trap (${t.cost})`;
        },

        action() {
          const now = performance.now();

            if (t.active) return;
            if (t.pending) return;
            if (now < t.cooldownUntil) return;
            if (player.points < t.cost) return;

            player.points -= t.cost;
            PlayerStats.addTrapBuy();

            t.pending = true;
            t.activateAt = now + 2000;
          }

      });
    }




  function initMysteryBoxes() {
    if (mysteryBoxes.length === 0) return;

    activeMysteryIndex = Math.floor(Math.random() * mysteryBoxes.length);

    mysteryBoxes.forEach((b, i) => {
      b.active = i === activeMysteryIndex;
    });
  }

  initMysteryBoxes();


  function trySpawnPowerDrop(x, y) {
  // üé≤ ONE roll per zombie
  if (Math.random() > POWER_DROP_CHANCE) return;

  // üéÅ Power-up pool (adjust if you want)
  const pool = [
    '2X',
    'CARPENTER',
    'INSTA',
    'MAX',
    'NUKE',
    'DEATH'
  ];

  const type = pool[Math.floor(Math.random() * pool.length)];

  powerDrops.push({
    x,
    y,
    type,
    spawnTime: performance.now()
  });

  playPowerupSpawnSound?.();
}


    

  /* ---------- ZOMBIE SPAWNS ---------- */
    if (Array.isArray(map.spawns)) {
      map.spawns.forEach(s => {
        zombieSpawns.push({
          x: s.x,
          y: s.y,
          linkedDoorId: s.linkedDoorId ?? null
        });
      });
    }

    /* ---- BOSS SPAWNS ---- */
    /* ---- BOSS SPAWNS ---- */
    bossSpawns.length = 0; // Clear existing, use global array
    if (Array.isArray(map.bossSpawns)) {
      map.bossSpawns.forEach(s => {
        bossSpawns.push({
          x: s.x,
          y: s.y,
          linkedDoorId: s.linkedDoorId ?? null
        });
      });
    }

    console.log("MAP APPLIED");
  };


  function gameOver() {
  const go = document.getElementById('gameOver');
  if (go) {
    renderGameOverStats();
    go.style.display = 'flex';
  }
}



  function zombieBlockedByBarrier(z) {
    const b = z.targetBarrier;
    if (!b) return false;

    // barrier exists and is NOT open / broken
    return !b.open;
  }



  function ownedGunCount() {
    return Object.keys(player.guns).length;
  }

  function removeCurrentGunIfNeeded() {
    const gunNames = Object.keys(player.guns);

    // Nothing to remove
    if (gunNames.length <= 1) return;

    // If holding pistol AND have another gun ‚Üí remove pistol
    if (
      player.currentGun.name === 'Pistol' &&
      gunNames.length >= MAX_GUNS
    ) {
      delete player.guns['Pistol'];

      // Switch to any remaining gun
      const next = Object.keys(player.guns)[0];
      player.currentGun = player.guns[next];
      return;
    }

    // Otherwise remove the currently held gun
    delete player.guns[player.currentGun.name];

    // Fallback to pistol or first available gun
    player.currentGun =
      player.guns['Pistol'] ??
      player.guns[Object.keys(player.guns)[0]];
  }


  function respawnZombieAtClosestSpawnToPlayer(z) {
  let best = null;
  let bestDist = Infinity;

  for (const s of zombieSpawns) {
    if (!isSpawnUnlocked(s)) continue;

    const dx = s.x - player.x;
    const dy = s.y - player.y;
    const d = dx * dx + dy * dy;

    if (d < bestDist) {
      bestDist = d;
      best = s;
    }
  }

  if (!best) return false;

  // small random offset so they don‚Äôt stack
  const angle = Math.random() * Math.PI * 2;
  const offset = 12;

  z.x = clamp(
    best.x + Math.cos(angle) * offset,
    20,
    WORLD_WIDTH - 20
  );
  z.y = clamp(
    best.y + Math.sin(angle) * offset,
    20,
    WORLD_HEIGHT - 20
  );

  z.lastX = z.x;
  z.lastY = z.y;
  z.stuckTime = 0;
  

  return true;
}


  function handleZombieStuck(z, dt) {
  // safety inits
  if (z.lastX == null) z.lastX = z.x;
  if (z.lastY == null) z.lastY = z.y;
  if (z.unstickAttempts == null) z.unstickAttempts = 0;
  if (z.unstickUntil == null) z.unstickUntil = 0;

  const dx = z.x - z.lastX;
  const dy = z.y - z.lastY;
  const moved = Math.hypot(dx, dy);

  // reset when movement detected
  if (moved >= ZOMBIE_STUCK_DIST) {
    z.stuckTime = 0;
    z.unstickAttempts = 0;
    z.lastX = z.x;
    z.lastY = z.y;
    return;
  }

  // accumulate stuck time
  z.stuckTime = (z.stuckTime || 0) + dt;

  // if currently in a short unstick period, try to keep moving (don't count that time)
  const now = performance.now();
  if (z.unstickUntil > now) {
    // apply a small continued shove while unstick is active
    if (z.vx == null) z.vx = 0;
    if (z.vy == null) z.vy = 0;
    z.x += z.vx * dt;
    z.y += z.vy * dt;
    return;
  }

  // only act when stuck long enough
  if (z.stuckTime < ZOMBIE_STUCK_TIME) return;

  // DON'T teleport or forcibly move certain zombies:
  if (z.isBoss) {
    // bosses should try nudges but not teleport
    tryNudge(z);
    z.stuckTime = 0;
    z.lastX = z.x;
    z.lastY = z.y;
    return;
  }

  // If zombie is actively forced (e.g., monkey bomb), try a nudge first
  if (z.forcedTarget) {
    tryNudge(z);
    z.stuckTime = 0;
    z.lastX = z.x;
    z.lastY = z.y;
    return;
  }

  // If zombie is meant to attack a closed barrier, do not teleport ‚Äî try stronger nudges first
  const b = z.targetBarrier;
  if (b && !b.open) {
    tryNudge(z, /*strong=*/true);
    z.stuckTime = 0;
    z.lastX = z.x;
    z.lastY = z.y;
    return;
  }

  // Staged strategy:
  // - Try a couple of small nudges before teleporting to keep gameplay natural.
  if (z.unstickAttempts < 2) {
    tryNudge(z);
    z.unstickAttempts++;
    z.stuckTime = 0;
    z.lastX = z.x;
    z.lastY = z.y;
    return;
  }

  // FINAL: try respawn at a spawn near the player, otherwise teleport near the player
  const didRespawn = respawnZombieAtClosestSpawnToPlayer(z);
  if (!didRespawn) {
    teleportZombieNearPlayer(z);
  }

  // reset counters after recovery
  z.unstickAttempts = 0;
  z.unstickUntil = 0;
  z.stuckTime = 0;
  z.lastX = z.x;
  z.lastY = z.y;
}

/* Helper: tryNudge(z, strong = false)
   - Applies a short random shove and temporary speed boost so collision resolution can free the zombie.
   - Does not persist beyond unstickDuration.
*/
function tryNudge(z, strong = false) {
  const now = performance.now();
  const unstickDuration = strong ? 500 : 260; // ms
  const nudgeSpeed = (z.speed || 60) * (strong ? 1.8 : 1.2);

  // random direction biased away from nearest barrier/wall when possible
  let angle = Math.random() * Math.PI * 2;

  // if targeting a barrier, bias away from barrier center
  if (z.targetBarrier) {
    const b = z.targetBarrier;
    const bx = b.x + b.w / 2;
    const by = b.y + b.h / 2;
    angle = Math.atan2(z.y - by, z.x - bx) + (Math.random() - 0.5) * 0.9;
  } else if (typeof player !== "undefined") {
    // small chance to bias toward player so nudges don't always move away
    if (Math.random() < 0.3) {
      angle = Math.atan2(player.y - z.y, player.x - z.x) + (Math.random() - 0.5) * 0.8;
    }
  }

  const nx = Math.cos(angle);
  const ny = Math.sin(angle);

  // assign a temporary velocity used by the main loop for a short while
  z.vx = nx * nudgeSpeed;
  z.vy = ny * nudgeSpeed;

  // also perform an immediate small position shift to break tight overlaps
  const immediateShift = strong ? 8 : 4;
  z.x += nx * immediateShift;
  z.y += ny * immediateShift;

  // temporarily increase wall speed boost so the zombie can push through small gaps
  z.wallSpeedBoost = Math.max(z.wallSpeedBoost || 1, strong ? 2.2 : 1.4);
  z.wallBoostTimer = Math.max(z.wallBoostTimer || 0, 400); // ms stored as ms in your codebase

  z.unstickUntil = now + unstickDuration;
}


function onRoundEnded() {
  if (roundTransitionTimer) return;

  // üîï PLAY ROUND END SOUND (isolated)
  RoundMusic.playEnd();
  PlayerStats.addRoundSurvived();

  roundTransitionTimer = setTimeout(() => {
    round++;
    uiRound.textContent = round;

    // üîî ROUND START SOUND
    startRoundSpawns();

    roundTransitionTimer = null;
  }, 2200);
}







let roundTransitionTimer = null;

function updateZombieCounter() {
  const alive = zombies.filter(z => z.alive !== false).length;
  uiZombiesLeft.textContent = alive;

  // Detect round end ONLY
  if (alive === 0 && gameStarted && !roundTransitionTimer) {
    onRoundEnded();
    RoundMusic.playEnd();
    PlayerStats.addRoundSurvived();
  }
}






  function teleportZombieNearPlayer(z) {
    const radius = 15 * 15; // keep your value

    const angle = Math.random() * Math.PI * 2;
    const dist = Math.sqrt(Math.random()) * radius;

    const nx = player.x + Math.cos(angle) * dist;
    const ny = player.y + Math.sin(angle) * dist;

    z.x = clamp(nx, 20, WORLD_WIDTH - 20);
    z.y = clamp(ny, 20, WORLD_HEIGHT - 20);

    z.lastX = z.x;
    z.lastY = z.y;
    z.stuckTime = 0;
  }



  function circleRectHit(cx, cy, r, rx, ry, rw, rh) {
    const x = clamp(cx, rx, rx + rw);
    const y = clamp(cy, ry, ry + rh);
    const dx = cx - x;
    const dy = cy - y;
    return dx * dx + dy * dy <= r * r;
  }



  // Game constants
  function W() { return canvas.width; }
  function H() { return canvas.height; }
  const TWO_PI = Math.PI * 2;

  const rnd = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const dist2 = (a,b) => { const dx = a.x - b.x, dy = a.y - b.y; return dx*dx + dy*dy; };

  const MAX_GUNS = 2;



  // Player
  const player = {
  x: WIDTH / 2,
  y: HEIGHT / 2,
  speed: 115,
  angle: 0,
  radius: 14,

  hitsMax: 4,
  hitsRemaining: 4,
  grenades: 2,
  grenadesMax: 5,

  // ‚úÖ HEALTH REGEN
  lastHitTime: 0,        // timestamp of last damage
  regenDelay: 15000,     // ms after last hit before regen starts
  regenRate: 0.8,        // hits per second

  points: 420,
  currentGun: null,
  trapDamageImmunityUntil: 0,

  guns: {},
  downed: false,
  alive: true,
  reviveTimer: 0,
  reviveDuration: 5,
  zombieFearTimer: 0,

  perks: {
    juggernog:false,
    speedCola:false,
    doubleTap:false,
    staminUp:false,
    quickRevive:false,
    quickReviveUsed:false
  },

  // üõ†Ô∏è BARRIER REPAIR STATE
  repairing: {
    barrier: null,
    lastRepairTime: 0
  }
};


// ===== ROUND CHANGE MUSIC =====
function applyRoundChangeVolume() {
  const v =
    (window.MASTER_VOLUME ?? 1) *
    (window.roundChangeVolume ?? 1);

  // Only apply to persistent audio
  if (RoundMusic.start) {
    RoundMusic.start.volume = v;
  }
}


// ===== ROUND CHANGE MUSIC =====
const RoundMusic = {
  start: new Audio('assets/audio/round_start.mp3'),

  playStart() {
    applyRoundChangeVolume();
    this.start.currentTime = 0;
    this.start.play().catch(() => {});
  },

  playEnd() {
    const endSound = new Audio('assets/audio/round_end.mp3');

    endSound.volume =
      (window.MASTER_VOLUME ?? 1) *
      (window.roundChangeVolume ?? 1);

    endSound.play().catch(err => {
      console.warn('Round end sound failed:', err);
    });
  }
};




  // Weapons
  function makeGun(name, {damage, fireRate, mag, reserve, reload, speed, auto=true, cost=0}) {
  return {
    name,
    damage,
    fireRate,
    mag,
    magMax: mag,
    reserve,
    reserveMax: reserve,
    reload,
    bulletSpeed: speed,
    auto,
    cooldown: 0,
    reloading: false,
    reloadTimer: 0,
    cost,

    // ===== ADD THESE =====
    upgradeLevel: 0,
    baseDamage: damage,
    baseReserveMax: reserve,
    upgradeCost: 5000
  };
}




  const pistol = makeGun('Pistol', { damage: 20, fireRate: 4, mag: 10, reserve: 60, reload: 1.5, speed: 550, auto:false, cost:0 });
  const smg    = makeGun('SMG',    { damage: 28, fireRate: 10, mag: 30, reserve: 180, reload: 2.5, speed: 650, auto:true, cost:750 });
  const ar     = makeGun('AR',     { damage: 32, fireRate: 6, mag: 25, reserve: 150, reload: 3.0, speed: 700, auto:true, cost:900 });
  const shotgun = makeGun('SHOTGUN',{ damage: 50, fireRate: 1, mag: 8,  reserve: 48,  reload: 5.5, speed: 600, auto:false, cost:1000 });
  const m1sus = makeGun('M1 SUS',   { damage: 45, fireRate: 2, mag: 10,  reserve: 50,  reload: 3.0, speed: 750, auto:false, cost:1000 });
  const lmg    = makeGun('LMG',    { damage: 35, fireRate: 8, mag: 60, reserve: 240, reload: 4.5, speed: 700, auto:true, cost:0 });
  const sniper = makeGun('Sniper', { damage: 120, fireRate: 1.5, mag: 5, reserve: 30, reload: 2.2, speed: 1000, auto:false, cost:0 });

  const deathMachine = makeGun('Death Machine', { damage: 999, fireRate: 12, mag: Infinity, reserve: Infinity, reload: 0, speed: 800, auto:true, cost:0 });

  const WALL_BUY_GUNS = {
    PISTOL: pistol,
    SMG: smg,
    AR: ar,
    SHOTGUN: shotgun,
    SNIPER: sniper,
    // üî• NEW WALL BUY
    "M1 SUS": structuredClone(MYSTERY_BOX_GUNS.find(g => g.name === 'M1 SUS'))
  };

  // Power-ups
  const POWER_TYPES = ['INSTA', 'NUKE', '2X', 'MAX', 'CARPENTER', 'DEATH'];
  const powerColors = {
    'INSTA':'#e74c3c',
    'NUKE':'#f1c40f',
    '2X':'#9b59b6',
    'MAX':'#3498db',
    'CARPENTER':'#2ecc71',
    'DEATH':'#95a5a6'
  };

  const activePowers = {
    insta:false, double:false, death:false,
    timers: { insta:0, double:0, death:0 }
  };

  // Round / Zombie
  
  let aliveCount = 0;

  // Round cooldown state
  let round = 1;
  // Boss round system
  let isBossRound = false;
  let bossRoundInterval = 5; // Boss round every 5 rounds
  let bossesRemaining = 0;
  RoundMusic.playStart(); 
  let roundCooldown = false;
  let roundCooldownEnd = 0;
  let showRoundBanner = false;
  let roundBannerText = '';


  // Spawn control (batch spawning)
  let spawnRemaining = 0;
  let spawnTimer = 0;





  // ============================
// SLIDER HELPERS (GLOBAL)
// ============================

function updateSlider(slider, mx, setter) {
  const t = (mx - slider.x) / slider.width;
  setter(Math.max(0, Math.min(1, t)));
}

function hitSlider(slider, mx, my) {
  return (
    mx >= slider.x &&
    mx <= slider.x + slider.width &&
    my >= slider.y - slider.knobRadius &&
    my <= slider.y + slider.height + slider.knobRadius
  );
}

  const GRENADE_SPAWN_OFFSET = player.radius + 6;

  function applyMonkeyAttraction(g) {
  for (const z of zombies) {
    if (!z.alive) continue;

    z.forcedTarget = true;
    z.forcedX = g.x;
    z.forcedY = g.y;
  }
}




  function throwGrenade() {
  if (player.grenades <= 0 || player.downed) return;

  player.grenades--;

  const angle = player.angle;
  const speed = 600;

  grenades.push({
    type: player.grenadeType || "normal", // üî• NEW
    x: player.x,
    y: player.y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    traveled: 0,
    armed: false,
    explodeAt: 0,
    attractUntil: 0 // üêí monkey only
  });
}





function grenadeHitsWall(x, y) {
  for (const w of walls) {
    if (
      x > w.x &&
      x < w.x + w.w &&
      y > w.y &&
      y < w.y + w.h
    ) {
      return true;
    }
  }
  return false;
}


const explosionSound = new Audio('assets/gun_sounds/grenade_explode.mp3');
explosionSound.volume = 0.6;

function playExplosionSound() {
  explosionSound.currentTime = 0;
  explosionSound.play();
}


function explodeGrenade(g) {
  grenadeExplosions.push({
    x: g.x,
    y: g.y,
    radius:
      g.type === "monkey" ? MONKEY_RADIUS : GRENADE_RADIUS,
    startTime: performance.now(),
    duration: 300 // ms
  });

  const radius =
    g.type === "monkey" ? MONKEY_RADIUS : GRENADE_RADIUS;

  // üí• ZOMBIES
  for (const z of zombies) {
    if (!z.alive) continue;

    const dx = z.x - g.x;
    const dy = z.y - g.y;

    if (dx * dx + dy * dy <= radius * radius) {
      z.alive = false;
      z.forcedTarget = false;
      PlayerStats.addKill();
      PlayerStats.addPoints(25);
      player.points += 25;
    }
  }

  if (g.type === "monkey") {
  for (const z of zombies) {
    z.forcedTarget = false;
  }
}


  // üíÄ PLAYER DAMAGE
  const pdx = player.x - g.x;
  const pdy = player.y - g.y;

  if (pdx * pdx + pdy * pdy <= radius * radius) {
    if (player.hitsRemaining <= 1) {
      // ‚ò†Ô∏è Player dies
      player.hitsRemaining = 0;
      player.downed = true;
      gameOver?.(); // if you have a game over handler
    } else {
      // üí• Knock player to last hit
      player.hitsRemaining = 1;
      player.lastHitTime = performance.now();
    }
  }

  playExplosionSound?.();
}




function updateGrenades(dt) {
  const now = performance.now();

  for (let i = grenades.length - 1; i >= 0; i--) {
    const g = grenades[i];

    // üü¢ Flying
    if (!g.armed) {
      const dx = g.vx * dt;
      const dy = g.vy * dt;

      g.x += dx;
      g.y += dy;
      g.traveled += Math.hypot(dx, dy);

      if (g.traveled >= GRENADE_THROW_DISTANCE) {
        g.vx = 0;
        g.vy = 0;
        g.armed = true;

        if (g.type === "monkey") {
          g.attractUntil = now + MONKEY_ATTRACT_TIME;
          g.explodeAt = now + MONKEY_EXPLODE_TIME;
        } else {
          g.explodeAt = now + GRENADE_FUSE_TIME;
        }
      }
    }
    // üî¥ Armed
    else {
      // üêí Monkey attraction phase
      if (g.type === "monkey" && now < g.attractUntil) {
        applyMonkeyAttraction(g);
      }

      if (now >= g.explodeAt) {
        explodeGrenade(g);

        // release zombies after explosion
        for (const z of zombies) z.forcedTarget = false;

        grenades.splice(i, 1);
      }
    }
  }
}

function drawGrenadeExplosions() {
  const now = performance.now();

  for (let i = grenadeExplosions.length - 1; i >= 0; i--) {
    const e = grenadeExplosions[i];
    const t = (now - e.startTime) / e.duration;

    if (t >= 1) {
      grenadeExplosions.splice(i, 1);
      continue;
    }

    // Ease-out expansion
    const progress = 1 - Math.pow(1 - t, 2);
    const r = progress * e.radius;

    ctx.strokeStyle = `rgba(255, 0, 0, ${1 - t})`;
    ctx.lineWidth = 3;

    ctx.beginPath();
    ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
    ctx.stroke();
  }
}






  function removeQuickReviveMachine() {

  for (let i = perkMachines.length - 1; i >= 0; i--) {
    if (perkMachines[i].perk === 'quickRevive') {
      perkMachines.splice(i, 1);
    }
  }

  for (let i = interacts.length - 1; i >= 0; i--) {
    if (interacts[i].type === 'perk' && interacts[i].perk === 'quickRevive') {
      interacts.splice(i, 1);
    }
  }

  // üö® FINAL LOCK
  player.quickReviveSoldOut = true;
}

  // ADD THIS HERE
  function rectCircleCollide(cx, cy, r, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) <= r * r;
  }



  function rollDropRarity(round) {
    let roll = Math.random();

    // Optional: better drops slightly more likely later rounds
    const roundBoost = Math.min(round * 0.05, 0.8);
    roll -= roundBoost;

    let acc = 0;
    for (const [rarity, data] of Object.entries(DROP_RARITIES)) {
      acc += data.chance;
      if (roll <= acc) return rarity;
    }
    return null;
  }


  // barrier object: {x,y,w,h,hp,hpMax,open:bool}
  function addBarrier(x,y,w,h) {
    barriers.push({x,y,w,h,hp:100, hpMax:100, open:false});
  }
  

  // Player init
  player.guns[pistol.name] = {...pistol};
  player.currentGun = player.guns[pistol.name];
  player.quickRevive = {
    buys: 0,
    maxBuys: 3
  };

  player.quickReviveSoldOut = false;

  function setPowerupVolume(t) {
  window.powerupVolume = Math.max(0, Math.min(1, t));
}
canvas.addEventListener('mousedown', e => {
  if (!gamePaused || !window.pauseRestartButton) return;

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const b = window.pauseRestartButton;

  if (
    mx >= b.x && mx <= b.x + b.w &&
    my >= b.y && my <= b.y + b.h
  ) {
    // üî• RESTART GAME
    gamePaused = false;
    restartGame();
    PlayerStats.reset();
  }
});


canvas.addEventListener('mousedown', e => {
  if (!gamePaused) return;

  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;
  const my = e.clientY - r.top;

  if (hitSlider(masterSlider, mx, my)) {
    masterSlider.dragging = true;
    updateSlider(masterSlider, mx, setMasterVolume);

  } else if (hitSlider(musicSlider, mx, my)) {
    musicSlider.dragging = true;
    updateSlider(musicSlider, mx, setMusicVolume);

  } else if (hitSlider(powerupSlider, mx, my)) {
    powerupSlider.dragging = true;
    updateSlider(powerupSlider, mx, setPowerupVolume);

  } else if (hitSlider(roundChangeSlider, mx, my)) {
    roundChangeSlider.dragging = true;
    updateSlider(
      roundChangeSlider,
      mx,
      v => {
        window.roundChangeVolume = v;
        applyRoundChangeVolume(); // üî• LIVE UPDATE
      }

    );
  }
});

canvas.addEventListener('mousemove', e => {
  if (!gamePaused) return;

  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;

  if (masterSlider.dragging) {
    updateSlider(masterSlider, mx, setMasterVolume);
  }
  if (musicSlider.dragging) {
    updateSlider(musicSlider, mx, setMusicVolume);
  }
  if (powerupSlider.dragging) {
    updateSlider(powerupSlider, mx, setPowerupVolume);
  }
  if (roundChangeSlider.dragging) {
    updateSlider(
      roundChangeSlider,
      mx,
      v => (window.roundChangeVolume = v)
    );
  }
});

canvas.addEventListener('mouseup', () => {
  masterSlider.dragging = false;
  musicSlider.dragging = false;
  powerupSlider.dragging = false;
  roundChangeSlider.dragging = false;
});






  // Input
    const keys = {};
    const mouse = { x: WIDTH/2, y: HEIGHT/2, down:false };

    window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'g') {
    throwGrenade();
  }
});



    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();

      if (e.key.toLowerCase() === 'r') {
        startReload(player.currentGun);
      }

      // ‚è∏ PAUSE TOGGLE (ESC)
      if (key === 'escape') {
        gamePaused = !gamePaused;



        // prevent stuck movement / shooting
        for (const k in keys) keys[k] = false;
        mouse.down = false;

        return;
      }

      // üî´ WEAPON SWAP
      if (key === '1') {
        swapGun();
        return;
      }

      keys[key] = true;
    });


    window.addEventListener('keyup', (e)=> { keys[e.key.toLowerCase()] = false; });
    canvas.addEventListener('mousemove', (e)=> {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', ()=> { mouse.down = true; });
    window.addEventListener('mouseup', ()=> { mouse.down = false; });

    function startRoundCooldown() {
      roundCooldown = true;
      roundCooldownEnd = now + 15000;

      showRoundBanner = true;
      roundBannerText = `ROUND ${round}`;
      roundBannerStart = performance.now();
    }
    
    function startReload(gun) {
      if (!gun) return;
      if (gun.reloading) return;
      if (gun.mag >= gun.magMax) return;
      if (gun.reserve <= 0) return;

      gun.reloading = true;
      playReloadSound(gun);

      const reloadMult = player.perks.speedCola ? 0.6 : 1;
      gun.reloadTimer = gun.reload * reloadMult;

    }



    function swapGun() {
      const gunNames = Object.keys(player.guns);

      // No swap if only one gun
      if (gunNames.length <= 1) return;

      const currentIndex = gunNames.indexOf(player.currentGun.name);
      const nextIndex = (currentIndex + 1) % gunNames.length;

      player.currentGun = player.guns[gunNames[nextIndex]];
    }


    function isInsideWall(x, y) {
    for (const w of walls) {
      const left   = w.x - w.w / 2;
      const right  = w.x + w.w / 2;
      const top    = w.y - w.h / 2;
      const bottom = w.y + w.h / 2;

      if (x > left && x < right && y > top && y < bottom) {
        return true;
      }
    }
    return false;
  }

  function clampToMap(x, y) {
    return {
      x: clamp(x, 20, WORLD_WIDTH - 20),
      y: clamp(y, 20, WORLD_HEIGHT - 20)
    };
  }


  function randomNearPlayer(radius = 50) {
    const angle = Math.random() * Math.PI * 2;
    const dist  = Math.random() * radius;
    return clampToMap(
      player.x + Math.cos(angle) * dist,
      player.y + Math.sin(angle) * dist
   );
  }

  

  function drawRoundBanner() {
    if (!showRoundBanner) return;

    const elapsed = performance.now() - roundBannerStart;
    if (elapsed > ROUND_BANNER_DURATION) {
      showRoundBanner = false;
      return;
    }

    const alpha = 1 - elapsed / ROUND_BANNER_DURATION;

    // üî• RESET TRANSFORM (THIS IS THE FIX)
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    ctx.globalAlpha = alpha;
    ctx.font = 'bold 56px system-ui';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.shadowColor = 'black';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 2;

    // ‚úÖ TRUE TOP-CENTER OF SCREEN
    ctx.fillText(
      roundBannerText,
      canvas.width / 2,
      80
    );

    ctx.restore();
  }



  function resolveCircleRotatedRectCollision(entity, rect) {
    const rot = (rect.rotation || 0) * Math.PI / 180;

  // Translate to rect space
    const dx = entity.x - rect.x;
    const dy = entity.y - rect.y;

    const cos = Math.cos(-rot);
    const sin = Math.sin(-rot);

    const lx = dx * cos - dy * sin;
    const ly = dx * sin + dy * cos;

    const hw = rect.w / 2;
    const hh = rect.h / 2;
    const r = entity.radius;

    // Find overlap in local space
    const overlapX = hw + r - Math.abs(lx);
    const overlapY = hh + r - Math.abs(ly);

    if (overlapX <= 0 || overlapY <= 0) return;

    let pushX = 0;
    let pushY = 0;

    // Resolve on smallest axis
    if (overlapX < overlapY) {
      pushX = lx > 0 ? overlapX : -overlapX;
    } else {
      pushY = ly > 0 ? overlapY : -overlapY;
    }

    // Rotate push vector back to world space
    const wx = pushX * cos + pushY * -sin;
    const wy = pushX * sin + pushY * cos;

    entity.x += wx;
    entity.y += wy;
  }

function rebuildDoorInteracts() {
  // Remove ALL existing door interacts
  for (let i = interacts.length - 1; i >= 0; i--) {
    if (interacts[i].type === 'door') {
      interacts.splice(i, 1);
    }
  }

  // Re-add only valid (closed & unopened-group) doors
  for (const d of doors) {
    if (d.open) continue;

    if (d.linkGroup) {
      const groupOpened = doors.some(
        od => od.linkGroup === d.linkGroup && od.open
      );
      if (groupOpened) continue;
    }

    interacts.push({
      type: 'door',
      x: d.x,
      y: d.y,
      cost: d.cost,
      label: `Open Door (${d.cost})`,
      action: () => tryBuyDoor(d)
    });
  }
}


  function resolveCircleRotatedRectCollision(entity, rect){
    const rx = rect.x - rect.w / 2;
    const ry = rect.y - rect.h / 2;

    if (!rectCircleCollide(entity.x, entity.y, entity.radius, rx, ry, rect.w, rect.h)) {
      return;
    }

    // Push entity out on smallest axis
    const dx = entity.x - rect.x;
    const dy = entity.y - rect.y;

    const overlapX = rect.w / 2 + entity.radius - Math.abs(dx);
    const overlapY = rect.h / 2 + entity.radius - Math.abs(dy);

    if (overlapX < overlapY) {
      entity.x += dx > 0 ? overlapX : -overlapX;
    } else {
      entity.y += dy > 0 ? overlapY : -overlapY;
    }
  }


  function bulletHitsRect(b, r) {
    const cx = clamp(b.x, r.x, r.x + r.w);
    const cy = clamp(b.y, r.y, r.y + r.h);
    const dx = b.x - cx;
    const dy = b.y - cy;
    return (dx * dx + dy * dy) <= (b.radius * b.radius);
  }


    function barrierBetweenSpawnAndPlayer(spawnX, spawnY, barrier) {
  // Simple axis check (works for your corridor-style maps)
  const bx = barrier.x + barrier.w / 2;
  const by = barrier.y + barrier.h / 2;

  // If spawn and player are on opposite sides of the barrier
  const spawnSideX = spawnX < bx;
  const playerSideX = player.x < bx;

  const spawnSideY = spawnY < by;
  const playerSideY = player.y < by;

  return spawnSideX !== playerSideX || spawnSideY !== playerSideY;
}


  
  // ---------- NEW: Circle collision helpers ----------
  function resolveCircleCollision(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = (a.r || a.radius) + (b.r || b.radius);

    if (dist === 0 || dist >= minDist) return;

    const overlap = minDist - dist;
    const nx = dx / dist;
    const ny = dy / dist;

    // Push both apart evenly
    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;
  }
// --------------------------------------------------


// ===== EMPTY GUN SOUND =====
const emptyGunAudio = new Audio('assets/gun_sounds/empty_click.mp3');
emptyGunAudio.volume = 1;

let lastEmptySoundTime = 0;

function playEmptyGunSound() {
  const now = performance.now();

  // prevent spam (1 click every 200ms max)
  if (now - lastEmptySoundTime < 200) return;
  lastEmptySoundTime = now;

  const sfx = emptyGunAudio.cloneNode();
  sfx.volume = window.MASTER_VOLUME ?? 0.6;
  sfx.play();
}



  // Actions
  function tryBuyGun(gun, cost) {
    if (player.points >= cost) {
      player.points -= cost;
      if (!player.guns[gun.name]) player.guns[gun.name] = {...gun};
      player.currentGun = player.guns[gun.name];
    }
  }

  function tryBuyAmmoOrGun(gun, cost) {
    const owned = !!player.guns[gun.name];

  // ---------- BUY NEW GUN ----------
    if (!owned) {
      if (player.points < cost) return;

    // Enforce max guns
      if (ownedGunCount() >= MAX_GUNS) {
        removeCurrentGunIfNeeded();
      }

      player.points -= cost;
      player.guns[gun.name] = structuredClone(gun);
      player.currentGun = player.guns[gun.name];
      return;
    }

    // ---------- AMMO REFILL ----------
    const g = player.guns[gun.name];

    let ammoCost = Math.floor(cost / 2);

    // üî• Increase ammo cost if gun is upgraded
    if (g.upgradeLevel > 0) {
      ammoCost = Math.floor(ammoCost * 3.5);
    }

    if (player.points < ammoCost) return;

    player.points -= ammoCost;

    if (g.mag !== Infinity) {
      g.mag = g.magMax;
      g.reserve = g.reserveMax;
    }
  }


  function resetAllPerkEffects() {
  // ---- Reset perk flags ----
    for (const key in player.perks) {
      player.perks[key] = false;
    }

  // ---- Reset core stats ----
    player.speed = PLAYER_DEFAULTS.speed;

    player.hitsMax = PLAYER_DEFAULTS.hitsMax;
    player.hitsRemaining = player.hitsMax;

  // ---- Reset revive / fear logic ----
    player.reviveDuration = PLAYER_DEFAULTS.reviveDuration;
    player.zombieFearTimer = 0;

  // ---- Reset Quick Revive internal state ----
    player.quickRevive.level = 0;
    player.quickRevive.cost = player.quickRevive.baseCost;
    player.quickRevive.regenMultiplier = 1;

  // ---- Safety: clear any perk side-effects ----
    player.lastHitTime = performance.now();
  }


  function updateZombieUI() {
    if (!uiZombiesLeft) return;

    let count = 0;
    for (const z of zombies) {
      if (z.alive) count++;
    }

    uiZombiesLeft.textContent = count;
  }


  function drawRoundBanner() {
  if (!showRoundBanner) return;

  const elapsed = performance.now() - roundBannerStart;
  if (elapsed > ROUND_BANNER_DURATION) {
    showRoundBanner = false;
    return;
  }

  const alpha = 1 - elapsed / ROUND_BANNER_DURATION;

  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  ctx.globalAlpha = alpha;

  // üî¥ BIG RED ROUND NUMBER
  ctx.font = 'bold 96px system-ui';
  ctx.fillStyle = '#e74c3c';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = 'black';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 4;

  ctx.fillText(
    round,
    canvas.width / 2,
    90
  );

  ctx.restore();
}


  function drawPowerUpIcons() {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const active = [];

  if (activePowers.insta) active.push('insta');
  if (activePowers.double) active.push('double');
  if (activePowers.death) active.push('death');

  if (active.length === 0) {
    ctx.restore();
    return;
  }

  const ICON_SIZE = 44;
  const SPACING = 12;

  const totalWidth =
    active.length * ICON_SIZE +
    (active.length - 1) * SPACING;

  const startX = canvas.width / 2 - totalWidth / 2;

  // ‚¨ÜÔ∏è POSITIONED ABOVE PERKS
  const y =
    canvas.height -
    (ICON_SIZE * 2) -
    65;

  active.forEach((key, i) => {
    const img = powerIcons[key];
    if (!img) return;

    const x = startX + i * (ICON_SIZE + SPACING);

  
    // clip icon (removes PNG black edges)
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(x, y, ICON_SIZE, ICON_SIZE, 6);
    ctx.clip();

    ctx.drawImage(img, x, y, ICON_SIZE, ICON_SIZE);
    ctx.restore();
  });

  ctx.restore();
}


  function drawPerkIcons() {
  // IMPORTANT: reset camera so HUD is screen-fixed
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    const ownedPerks = Object.keys(player.perks)
      .filter(p => player.perks[p] && p !== 'quickReviveUsed');

    if (ownedPerks.length === 0) {
      ctx.restore();
      return;
    }

    const ICON_SIZE = 44;
    const SPACING = 12;

    const totalWidth =
      ownedPerks.length * ICON_SIZE +
      (ownedPerks.length - 1) * SPACING;

    const startX = canvas.width / 2 - totalWidth / 2;
    const y = canvas.height - ICON_SIZE - 40; // bottom middle

    ownedPerks.forEach((perk, i) => {
      const img = perkIcons[perk];
      if (!img) return;

      const x = startX + i * (ICON_SIZE + SPACING);

    

    // ===== CLIP ICON (REMOVES BLACK BACKGROUND) =====
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(x, y, ICON_SIZE, ICON_SIZE, 6);
      ctx.clip();

      ctx.drawImage(img, x, y, ICON_SIZE, ICON_SIZE);

      ctx.restore();
    });

    ctx.restore();
  }




  function tryMysteryBox(cost) {
  // ‚è±Ô∏è GLOBAL INTERACT COOLDOWN
  if (!canInteractNow()) return;

  const box = mysteryBoxes[activeMysteryIndex];
  if (!box || !box.active) return;
  if (player.points < cost) return;

  // ‚úÖ COMMIT INTERACTION
  markInteractUsed();

  player.points -= cost;
  mysterySpinCount++;

  const roll = Math.random();

  // üêí MONKEY BOMB ‚Äî 12% chance
  if (roll < 0.12) {
    startMysteryRoll("üêí MONKEY BOMB", () => {
      console.log("MYSTERY BOX: MONKEY BOMB");

      giveMonkeyBombs(); // üî• replaces grenades

      // üì¶ MOVE BOX CHECK
      if (mysterySpinCount >= MYSTERY_MOVE_SPINS) {
        mysterySpinCount = 0;
        if (Math.random() < MYSTERY_MOVE_CHANCE) {
          moveMysteryBox();
        }
      }
    });

    return; // ‚ùó STOP ‚Äî no gun awarded
  }

  // üî´ GUN ROLL
  const pick =
    MYSTERY_BOX_GUNS[Math.floor(Math.random() * MYSTERY_BOX_GUNS.length)];

  startMysteryRoll(pick.name.toUpperCase(), () => {
    const alreadyOwned = !!player.guns[pick.name];

    // üîí ENFORCE MAX GUNS
    if (!alreadyOwned && ownedGunCount() >= MAX_GUNS) {
      removeCurrentGunIfNeeded();
    }

    // üéÅ Give gun if not owned
    if (!player.guns[pick.name]) {
      player.guns[pick.name] = structuredClone(pick);
    }

    player.currentGun = player.guns[pick.name];

    // üì¶ MOVE BOX CHECK
    if (mysterySpinCount >= MYSTERY_MOVE_SPINS) {
      mysterySpinCount = 0;
      if (Math.random() < MYSTERY_MOVE_CHANCE) {
        moveMysteryBox();
      }
    }
  });
}



// ===== MYSTERY BOX REWARDS =====

function giveMonkeyBombs() {
  player.grenadeType = "monkey"; // replaces grenades
  player.grenades = 3;
}





  function moveMysteryBox() {
    if (mysteryBoxes.length <= 1) return;

    const prevIndex = activeMysteryIndex;

    // üî• HARD RESET ‚Äî only ONE box may be active
    for (const b of mysteryBoxes) {
      b.active = false;
    }

    // build list of valid targets (not the previous one)
    const candidates = mysteryBoxes
      .map((_, i) => i)
      .filter(i => i !== prevIndex);

    // guaranteed different box
    const newIndex =
      candidates[Math.floor(Math.random() * candidates.length)];

    mysteryBoxes[newIndex].active = true;
    activeMysteryIndex = newIndex;
  }


  const mysteryBoxDisplay = document.getElementById("mysteryBoxDisplay");

let mysteryRolling = false;

function getMysteryBoxPool() {
  return [
    "üêí MONKEY BOMB",
    ...MYSTERY_BOX_GUNS.map(g => g.name.toUpperCase())
  ];
}

function startMysteryRoll(finalText, onFinish) {
  if (mysteryRolling) return;
  mysteryRolling = true;

  const pool = getMysteryBoxPool();
  mysteryBoxDisplay.style.display = "block";

  let index = 0;

  const interval = setInterval(() => {
    mysteryBoxDisplay.textContent =
      pool[index % pool.length];
    index++;
  }, 90);

  setTimeout(() => {
    clearInterval(interval);

    // üéØ FINAL RESULT
    mysteryBoxDisplay.textContent = finalText;

    setTimeout(() => {
      mysteryBoxDisplay.style.display = "none";
      mysteryRolling = false;
      onFinish?.();
    }, 1000);

  }, 2000);
}




  function restartGame() {
  if (!LOADED_MAP) return;

  // ---- CLEAR ALL RUNTIME ARRAYS ----
  zombies.length = 0;
  bullets.length = 0;
  powerDrops.length = 0;
  grenades.length = 0;           // ‚úÖ clear active grenades
  grenadeExplosions.length = 0;  // ‚úÖ clear explosion visuals
  gamePaused = false;
  roundTransitionTimer = null;

  // ---- RESET PLAYER ----
  player.alive = true;
  player.downed = false;
  player.hitsMax = 4;
  player.hitsRemaining = 4;
  player.points = 420;

  // ‚úÖ RESET GRENADES
  player.grenadeType = "normal"; // back to regular grenades
  player.grenades = 4;           // ‚Üê requested change
  PlayerStats.reset();

  player.perks = {
    juggernog:false,
    speedCola:false,
    doubleTap:false,
    staminUp:false,
    quickRevive:false,
    quickReviveUsed:false
  };

  // --- Reset Quick Revive bookkeeping so purchases are cleared on restart ---
  // This ensures the perk machine can be bought again from scratch.
  player.quickRevive = {
    buys: 0,
    maxBuys: 3
  };
  player.quickReviveSoldOut = false;
  // -----------------------------------------------------------------------

  // ---- RESET GUNS ----
  player.guns = {};
  player.guns[pistol.name] = structuredClone(pistol);
  player.currentGun = player.guns[pistol.name];

  // ---- RESET ROUND SYSTEM ----
  round = 1;
  RoundMusic.playStart();
  roundCooldown = false;
  spawnRemaining = 0;
  aliveCount = 0;

  // ---- RELOAD MAP ----
  loadMap(LOADED_MAP);

  // ---- START ROUND ----
  startRoundSpawns();

  // ---- HIDE GAME OVER ----
  document.getElementById('gameOver').style.display = 'none';
}



      function updateHealthRegen(dt) {
  // dead or downed players do not regen
  if (!player.alive || player.downed) return;

  // already full health
  if (player.hitsRemaining >= player.hitsMax) return;

  const now = performance.now();

  // wait for delay after last hit
  if (now - player.lastHitTime < player.regenDelay) return;

  // regen amount this frame
  const regenAmount = player.regenRate * dt;

  player.hitsRemaining = Math.min(
    player.hitsMax,
    player.hitsRemaining + regenAmount
  );
}
function hitSlider(slider, mx, my) {
  return (
    mx >= slider.x &&
    mx <= slider.x + slider.width &&
    my >= slider.y - slider.knobRadius &&
    my <= slider.y + slider.height + slider.knobRadius
  );
}


function drawSlider(slider, value) {
  ctx.fillStyle = '#555';
  ctx.fillRect(slider.x, slider.y, slider.width, slider.height);

  ctx.fillStyle = '#1abc9c';
  ctx.fillRect(slider.x, slider.y, slider.width * value, slider.height);

  const knobX = slider.x + slider.width * value;
  const knobY = slider.y + slider.height / 2;

  ctx.beginPath();
  ctx.arc(knobX, knobY, slider.knobRadius, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
}


function shouldZombieIgnoreBarriers(zombie) {
  const ALIVE_LIMIT_MS = 2 * 60 * 1000; // 2 minutes
  return performance.now() - zombie.spawnTime >= ALIVE_LIMIT_MS;
}



function tryBuyPerk(perk, cost) {

  // =============================
  // QUICK REVIVE (HARD LIMITED)
  // =============================
  if (perk === 'quickRevive') {

    // üö® SOLD OUT = ABSOLUTE STOP
    if (player.quickReviveSoldOut) return;

    // ‚ùå already active (must be used first)
    if (player.perks.quickRevive) return;

    // ‚ùå no buys left
    if (player.quickRevive.buys >= player.quickRevive.maxBuys) {
      player.quickReviveSoldOut = true;
      removeQuickReviveMachine();
      return;
    }

    // ‚ùå not enough points
    if (player.points < cost) return;

    // PAY
    player.points -= cost;

    // COUNT BUY
    player.quickRevive.buys++;

    // ACTIVATE
    player.perks.quickRevive = true;
    player.perks.quickReviveUsed = false;

    // üö® SOLD OUT AFTER 3RD BUY (GUARANTEED)
    if (player.quickRevive.buys === player.quickRevive.maxBuys) {
      player.quickReviveSoldOut = true;
      removeQuickReviveMachine();
    }

    return;
  }

  // =============================
  // NORMAL PERKS
  // =============================
  if (player.perks[perk]) return;
  if (player.points < cost) return;

  player.points -= cost;
  player.perks[perk] = true;

  if (perk === 'juggernog') {
    player.hitsMax = 7;
    player.hitsRemaining = clamp(player.hitsRemaining + 2, 0, player.hitsMax);

  } else if (perk === 'speedCola') {
    for (const g of Object.values(player.guns)) g.reload *= 0.6;

  } else if (perk === 'doubleTap') {
    for (const g of Object.values(player.guns)) {
      g.damage *= 1.15;
      g.fireRate *= 1.15;
    }

  } else if (perk === 'staminUp') {
    player.speed *= 1.85;
  }
}

 function drawPauseOverlay() {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // Dark background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 350);



  ctx.font = '20px system-ui';

  // ===== MASTER VOLUME =====
const UI_Y_OFFSET = -210;

// ===== GUN VOLUME =====
ctx.fillText(
  `Gun Volume: ${Math.round(window.MASTER_VOLUME * 100)}%`,
  canvas.width / 2,
  canvas.height / 2 - 80 + UI_Y_OFFSET
);

masterSlider.x = canvas.width / 2 - masterSlider.width / 2;
masterSlider.y = canvas.height / 2 - 55 + UI_Y_OFFSET;

drawSlider(masterSlider, window.MASTER_VOLUME);

// ===== MUSIC VOLUME =====
ctx.fillText(
  `Music Volume: ${Math.round(window.musicVolume * 100)}%`,
  canvas.width / 2,
  canvas.height / 2 - 10 + UI_Y_OFFSET
);

musicSlider.x = canvas.width / 2 - musicSlider.width / 2;
musicSlider.y = canvas.height / 2 + 15 + UI_Y_OFFSET;

drawSlider(musicSlider, window.musicVolume);

// ===== POWER-UP VOLUME =====
ctx.fillText(
  `Power-Up Volume: ${Math.round(window.powerupVolume * 100)}%`,
  canvas.width / 2,
  canvas.height / 2 + 50 + UI_Y_OFFSET
);

powerupSlider.x = canvas.width / 2 - powerupSlider.width / 2;
powerupSlider.y = canvas.height / 2 + 75 + UI_Y_OFFSET;

drawSlider(powerupSlider, window.powerupVolume);

// ===== ROUND CHANGE VOLUME =====
ctx.fillText(
  `Round Change Volume: ${Math.round(window.roundChangeVolume * 100)}%`,
  canvas.width / 2,
  canvas.height / 2 + 110 + UI_Y_OFFSET
);

roundChangeSlider.x = canvas.width / 2 - roundChangeSlider.width / 2;
roundChangeSlider.y = canvas.height / 2 + 135 + UI_Y_OFFSET;

drawSlider(roundChangeSlider, window.roundChangeVolume);

// ===== PLAYER LEVEL / EXP =====
const expBarWidth = 260;
const expBarHeight = 12;

const expPct = Math.min(
  1,
  PlayerInfo.exp / PlayerInfo.expToNext
);

const expX = canvas.width / 2 - expBarWidth / 2;
const expY = canvas.height / 2 - 420;

// label
ctx.fillStyle = '#ffffff';
ctx.font = 'bold 20px system-ui';
ctx.textAlign = 'center';
ctx.fillText(
  `LEVEL ${PlayerInfo.level}`,
  canvas.width / 2,
  expY - 14
);

// bar background
ctx.fillStyle = '#333';
ctx.fillRect(expX, expY, expBarWidth, expBarHeight);

// bar fill
ctx.fillStyle = '#2ecc71';
ctx.fillRect(
  expX,
  expY,
  expBarWidth * expPct,
  expBarHeight
);

// bar border
ctx.strokeStyle = '#ffffff';
ctx.lineWidth = 1;
ctx.strokeRect(expX, expY, expBarWidth, expBarHeight);

// exp text
ctx.font = '14px system-ui';
ctx.fillStyle = '#ffffff';
ctx.fillText(
  `${PlayerInfo.exp} / ${PlayerInfo.expToNext} EXP`,
  canvas.width / 2,
  expY + 24
);



// ===== FOOTER / CONTROLS =====
ctx.font = '16px system-ui';
ctx.fillText('Press ESC to resume', canvas.width / 2, canvas.height / 2 + 175 + UI_Y_OFFSET);

ctx.fillText('-- CONTROLS --', canvas.width / 2, canvas.height / 2 + 205 + UI_Y_OFFSET);
ctx.fillText('W A S D = Move', canvas.width / 2, canvas.height / 2 + 220 + UI_Y_OFFSET);
ctx.fillText('Mouse = Aim', canvas.width / 2, canvas.height / 2 + 235 + UI_Y_OFFSET);
ctx.fillText('Left Click = Shoot', canvas.width / 2, canvas.height / 2 + 250 + UI_Y_OFFSET);
ctx.fillText('R = Reload', canvas.width / 2, canvas.height / 2 + 265 + UI_Y_OFFSET);
ctx.fillText('E = Interact', canvas.width / 2, canvas.height / 2 + 280 + UI_Y_OFFSET);
ctx.fillText('1 = Swap Weapon', canvas.width / 2, canvas.height / 2 + 295 + UI_Y_OFFSET);
ctx.fillText('G = Throw Grenades / Monkeys', canvas.width / 2, canvas.height / 2 + 310 + UI_Y_OFFSET);

// ===== RESTART BUTTON (PAUSE MENU ONLY) =====
if (gamePaused) {

  const restartBtn = {
    x: canvas.width / 2 - 110,
    y: canvas.height / 2 + 125,
    w: 220,
    h: 44
  };

  // button background
  ctx.fillStyle = '#8b0000';
  ctx.fillRect(restartBtn.x, restartBtn.y, restartBtn.w, restartBtn.h);

  // button border
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.strokeRect(restartBtn.x, restartBtn.y, restartBtn.w, restartBtn.h);

  // button text
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 26px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.fillText(
    'RESTART GAME',
    restartBtn.x + restartBtn.w / 2,
    restartBtn.y + restartBtn.h / 2
  );

  // expose for click detection
  window.pauseRestartButton = restartBtn;
}



ctx.restore();

drawPauseStatsBar(ctx, canvas);


}

function checkZombiePassedBarrier(z, barrier) {
  if (!barrier || barrier.open) return false;
  if (z.ignoreBarriers) return false;

  const zx = z.x;
  const zy = z.y;

  // Barrier center
  const bx = barrier.x + barrier.w / 2;
  const by = barrier.y + barrier.h / 2;

  // Previous position
  const px = z.lastX;
  const py = z.lastY;

  // Did zombie cross the barrier rectangle?
  const wasOutside =
    px < barrier.x ||
    px > barrier.x + barrier.w ||
    py < barrier.y ||
    py > barrier.y + barrier.h;

  const nowInside =
    zx >= barrier.x &&
    zx <= barrier.x + barrier.w &&
    zy >= barrier.y &&
    zy <= barrier.y + barrier.h;

  // If zombie entered the barrier zone ‚Üí it passed through
  if (wasOutside && nowInside) {
    z.ignoreBarriers = true;
    z.passedBarrier = true;
    z.targetBarrier = null;
    return true;
  }

  return false;
}


function resolveZombieWallCollisionWithBoost(z, wall) {
  // ---- safety init ----
  if (z.wallSpeedBoost == null) z.wallSpeedBoost = 1;
  if (z.wallBoostTimer == null) z.wallBoostTimer = 0;

  let touching = false;

  if (wall.slope) {
    const r = z.r || z.radius || 12;

    // detect slope overlap FIRST
    const tri = getSlopeTriangle(wall);
    if (tri && pointInTriangle(z.x, z.y, tri)) {
      touching = true;
    }

    // resolve collision
    resolveCircleSlopeCollision(z, wall, r);

  } else {
    // normal wall overlap check
    const left   = wall.x - wall.w / 2;
    const right  = wall.x + wall.w / 2;
    const top    = wall.y - wall.h / 2;
    const bottom = wall.y + wall.h / 2;

    const r = z.r || z.radius || 12;

    if (
      z.x + r > left &&
      z.x - r < right &&
      z.y + r > top &&
      z.y - r < bottom
    ) {
      touching = true;
    }

    resolveWallCollision(z, wall);
  }

  // ---- APPLY BOOST ----
  if (touching) {
    z.wallSpeedBoost = Math.min(3, z.wallSpeedBoost + 0.6);
    z.wallBoostTimer = 250; // ms
  }
}

function handleZombieAttacks(z, now) {
  if (!z.alive) return;
  if (player.downed) return;

  const dx = z.x - player.x;
  const dy = z.y - player.y;
  const dist = Math.hypot(dx, dy);

  // Use attackRange if defined (boss), otherwise default reach
  const reach = z.attackRange || (z.isBoss ? 35 : 26);

  if (dist <= reach) {
    // Initialize lastAttackTime if not set
    if (z.lastAttackTime == null) z.lastAttackTime = 0;
    if (z.attackCooldown == null) z.attackCooldown = z.isBoss ? 2.0 : 1.5;

    if (now - z.lastAttackTime >= z.attackCooldown * 1000) {
      z.lastAttackTime = now;
      
      // Skip if trap immunity active
      if (now < player.trapDamageImmunityUntil) return;
      
      // Boss zombies deal more damage
      const damage = z.isBoss ? (typeof BOSS_CONFIG !== 'undefined' ? BOSS_CONFIG.damageMultiplier : 2) : 1;
      player.hitsRemaining -= damage;
      player.lastHitTime = performance.now();
      
      // Add boss kill tracking when player dies to boss
      if (player.hitsRemaining <= 0 && z.isBoss) {
        // Boss got the killing blow - tracked elsewhere on zombie death
      }
    }
  }
}




  // Zombie spawning
function roundZombieHP(r) {
  const base = 100; // base HP round 1
  return Math.floor(base * Math.pow(1.05, r-1));
}

function startRoundSpawns() {
  // Check if this should be a boss round AND if boss spawns exist
  const hasBossSpawns = bossSpawns.length > 0 && bossSpawns.filter(isSpawnUnlocked).length > 0;
  isBossRound = (round % bossRoundInterval === 0) && round > 0 && hasBossSpawns;

  if (isBossRound) {
    // Boss round: spawn boss zombies
    spawnBossZombies();
    
    spawnRemaining = 0; // No regular zombies on boss rounds

    // Show boss round banner
    showRoundBanner = true;
    roundBannerText = `BOSS ROUND ${round}`;
    roundBannerStart = performance.now();

  } else {
    // Normal round
    const count = 6 + round * 2;
    spawnRemaining = count;
    spawnTimer = 0;
    bossZombiesRemaining = 0;
  }
}


  // ---------- Rectangle ‚Üî Circle collision helper ----------
  function rectCircleCollide(cx, cy, r, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) <= r * r;
  }


  function getActiveZombieSpawns() {
    return zombieSpawns.filter(s => {
      if (!s.doorId) return true; // always active

      const door = doors.find(d => d.id === s.doorId);
      return door && door.open;
    });
  }

  


  function spawnBatch(hp, batchCount) {
  const activeSpawns = zombieSpawns.filter(isSpawnUnlocked);
  if (activeSpawns.length === 0) return;

  for (let i = 0; i < batchCount; i++) {
    const s = activeSpawns[Math.floor(Math.random() * activeSpawns.length)];

    let targetBarrier = null;

    // Assign barrier ONLY if zombie spawns behind it
    if (barriers && barriers.length > 0) {
      for (const b of barriers) {
        if (!b.open && barrierBetweenSpawnAndPlayer(s.x, s.y, b)) {
          targetBarrier = b;
          break;
        }
      }
    }

    // Try to find a non-overlapping spawn position
    let spawnX = s.x;
    let spawnY = s.y;
    const zombieRadius = 12;
    let attempts = 0;
    const maxAttempts = 20;
    
    while (attempts < maxAttempts) {
      // Add small random offset
      const angle = Math.random() * Math.PI * 2;
      const offset = 15 + Math.random() * 20; // Increased offset
      const tryX = s.x + Math.cos(angle) * offset;
      const tryY = s.y + Math.sin(angle) * offset;
      
      // Check if position is inside walls
      if (isInsideWall(tryX, tryY)) {
        attempts++;
        continue;
      }
      
      // Check if position overlaps with other zombies
      if (isPositionOverlappingWithZombies(tryX, tryY, zombieRadius)) {
        attempts++;
        continue;
      }
      
      // Position is good
      spawnX = tryX;
      spawnY = tryY;
      break;
    }

    zombies.push({
      x: spawnX,
      y: spawnY,
      r: 12,
      speed: rnd(6, 6),

      hp,
      hpMax: hp,

      targetBarrier: targetBarrier,
      spawnedBehindBarrier: !!targetBarrier,

      ignoreBarriers: false,
      passedBarriers: new Set(),
      
      spawnTime: performance.now(),

      // Barrier / player attack logic
      attackBarrierDps: 12,
      barrierHitCooldown: 1.5,
      playerHitCooldown: 0,

      // Movement / stuck logic
      lastX: spawnX,
      lastY: spawnY,
      stuckTime: 0,

      alive: true
    });
  }
}


// Boss spawn queue variables (add near BOSS_CONFIG)
let bossSpawnQueue = [];
let bossSpawnTimer = 0;
const BOSS_SPAWN_INTERVAL = 3000; // 3 seconds between each boss spawn

function spawnBossZombies() {
  // Only spawn at boss spawn locations
  const spawns = bossSpawns.filter(isSpawnUnlocked);
  if (spawns.length === 0) return;
  
  // Spawn 5-10 boss zombies
  const count = Math.floor(Math.random() * (BOSS_CONFIG.maxSpawn - BOSS_CONFIG.minSpawn + 1)) + BOSS_CONFIG.minSpawn;
  bossZombiesRemaining = count;
  
  // HP scales with round: base HP * multiplier * (1 + round * 0.2)
  const roundScaling = 1 + (round * 0.2);
  const baseHP = roundZombieHP(round) * BOSS_CONFIG.healthMultiplier * roundScaling;
  
  // Boss radius (increased size)
  const bossRadius = 12 * BOSS_CONFIG.sizeMultiplier;
  
  for (let i = 0; i < count; i++) {
    const s = spawns[Math.floor(Math.random() * spawns.length)];
    
    // Try to find a non-overlapping spawn position
    let spawnX = s.x;
    let spawnY = s.y;
    let attempts = 0;
    const maxAttempts = 20;
    
    while (attempts < maxAttempts) {
      // Add larger random offset for bosses
      const angle = Math.random() * Math.PI * 2;
      const offset = 25 + Math.random() * 30; // Larger offset for bosses
      const tryX = s.x + Math.cos(angle) * offset;
      const tryY = s.y + Math.sin(angle) * offset;
      
      // Check if position is inside walls
      if (isInsideWall(tryX, tryY)) {
        attempts++;
        continue;
      }
      
      // Check if position overlaps with other zombies (including bosses)
      if (isPositionOverlappingWithZombies(tryX, tryY, bossRadius)) {
        attempts++;
        continue;
      }
      
      // Position is good
      spawnX = tryX;
      spawnY = tryY;
      break;
    }
    
    zombies.push({
      x: spawnX, y: spawnY,
      r: bossRadius,
      speed: rnd(9, 9) * BOSS_CONFIG.speedMultiplier,
      hp: baseHP, hpMax: baseHP,
      isBoss: true,
      targetBarrier: null,
      spawnedBehindBarrier: false,
      ignoreBarriers: true,
      passedBarriers: new Set(),
      spawnTime: performance.now(),
      attackBarrierDps: 24,
      barrierHitCooldown: 1.0,
      playerHitCooldown: 0,
      attackRange: 30,
      lastX: spawnX, lastY: spawnY,
      stuckTime: 0,
      alive: true
    });
  }
}

// Add this to your zombie death/kill logic where you handle z.hp <= 0:
// (Find where you award points for zombie kills and add this check)


function isPositionOverlappingWithZombies(x, y, radius, excludeZombie = null) {
  for (const z of zombies) {
    if (z === excludeZombie || !z.alive) continue;
    const dx = x - z.x;
    const dy = y - z.y;
    const dist = Math.hypot(dx, dy);
    const minDist = radius + (z.r || z.radius || 12);
    if (dist < minDist) {
      return true;
    }
  }
  return false;
}





function checkZombiePassedBarrier(z, barrier) {
  if (z.ignoreBarriers) return;
  if (barrier.open) return;

  // barrier bounds (top-left based, same as your collision)
  const left   = barrier.x;
  const right  = barrier.x + barrier.w;
  const top    = barrier.y;
  const bottom = barrier.y + barrier.h;

  // previous & current positions
  const px = z.lastX ?? z.x;
  const py = z.lastY ?? z.y;
  const cx = z.x;
  const cy = z.y;

  // determine which side zombie was on
  const wasOutside =
    px < left || px > right || py < top || py > bottom;

  const isInside =
    cx > left && cx < right && cy > top && cy < bottom;

  // crossed THROUGH the barrier
  if (wasOutside && isInside) {
    z.passedBarriers.add(barrier);
  }

  // once fully past (inside ‚Üí outside opposite side)
  const exited =
    z.passedBarriers.has(barrier) &&
    (cx < left || cx > right || cy < top || cy > bottom);

  if (exited) {
    z.ignoreBarriers = true;

    // üîí force targeting player only
    z.targetBarrier = null;
    z.blockedByBarrier = null;
  }
}
  

function clearBarrierIfPassed(z) {
  const b = z.targetBarrier;
  if (!b || b.open) {
    z.targetBarrier = null;
    return;
  }

  // distance zombie ‚Üí player
  const dzp =
    (z.x - player.x) ** 2 +
    (z.y - player.y) ** 2;

  // distance barrier center ‚Üí player
  const bx = b.x + b.w / 2;
  const by = b.y + b.h / 2;
  const dbp =
    (bx - player.x) ** 2 +
    (by - player.y) ** 2;

  // ‚úÖ zombie is past the barrier
  if (dzp < dbp) {
    z.targetBarrier = null;
  }
}






  function tryUpgradeCurrentGun(stationCost) {
    const g = player.currentGun;
    if (!g) return;

    // safety init
    if (g.upgradeLevel == null) {
      g.upgradeLevel = 0;
      g.baseDamage = g.damage;
      g.baseReserveMax = g.reserveMax;
      g.upgradeCost = 5000;
      g.upgradeCost = Math.round(g.upgradeCost * 1.25);
    }

    const cost = stationCost ?? g.upgradeCost;
    if (player.points < cost) return;

    player.points -= cost;
    upgradeGun(g);
    PlayerStats.addUpgrade();
  }




  // Bullets
  function shoot() {
    const g = player.currentGun;
    if (!g) return;

    // ‚õî block firing while reloading
    if (g.reloading) return;

    // üîÅ auto-reload when empty (DO NOT fire)
    if (g.mag <= 0 && g.mag !== Infinity) {
      if (g.reserve > 0) startReload(g);
      playEmptyGunSound();
      return;
    }

    // ‚è±Ô∏è fire rate cooldown
    if (g.cooldown > 0) return;

    const angle = player.angle;
    const speed = g.bulletSpeed;

    bullets.push({
      x: player.x,
      y: player.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      damage: g.damage,
      life: 1.2,
      radius: 3
    });
    playGunSound(g);
    // üî´ consume ammo
    if (g.mag !== Infinity) g.mag--;

    // ‚è≥ reset fire cooldown
    g.cooldown = 1 / g.fireRate;
  }

function updatePowerDrops(now) {
  for (let i = powerDrops.length - 1; i >= 0; i--) {
    const p = powerDrops[i];

    // despawn after 30s
    if (now - p.spawnedAt >= p.lifetime) {
      powerDrops.splice(i, 1);
    }
  }
}



  // Power-up drops
  function tryDropPower(x, y) {
  const chance = 0.0085; 
  if (Math.random() > chance) return;

  const weights = [
    { t: 'INSTA',     w: 0.35 },
    { t: 'NUKE',      w: 0.5 },
    { t: '2X',        w: 0.6 },
    { t: 'MAX',       w: 0.3 },
    { t: 'CARPENTER', w: 0.7 },
    { t: 'DEATH',     w: 0.2 }
  ];

  const total = weights.reduce((a, b) => a + b.w, 0);
  let r = Math.random() * total;
  let pick = weights[0].t;

  for (const w of weights) {
    if ((r -= w.w) <= 0) {
      pick = w.t;
      break;
    }
  }

  powerDrops.push({
    type: pick,
    x,
    y,
    r: 16,

    // ‚úÖ FIXED LIFETIME SYSTEM
    spawnedAt: performance.now(),
    lifetime: 30000 // 30 seconds in ms
  });
}




  function pickupPower(p) {
    playPowerupSound(p.type);
    if (p.type === 'INSTA') {
      activePowers.insta = true;
      activePowers.timers.insta = now + 30_000;
    } else if (p.type === '2X') {
      activePowers.double = true;
      activePowers.timers.double = now + 30_000;
    } else if (p.type === 'DEATH') {
      activePowers.death = true;
      activePowers.timers.death = now + 15_000;
      player.prevGunBeforeDeath = player.currentGun;
      player.currentGun = deathMachine;
    } else if (p.type === 'NUKE') {
      for (const z of zombies) if (z.alive) { z.alive=false; awardKill(); tryDropPower(z.x,z.y); }
      // ‚úÖ BONUS POINTS
      player.points += 420;
      PlayerStats.addPoints(420);
    } else if (p.type === 'MAX') {
      for (const g of Object.values(player.guns)) {
        if (g.mag !== Infinity) { g.mag = g.magMax; g.reserve = g.reserveMax; }
      }
      player.grenades = Math.min(
        player.grenades + 5,
        player.grenadesMax
      );
    } else if (p.type === 'CARPENTER') {
      for (const b of barriers) { b.hp = b.hpMax; b.open = false; }
      // ‚úÖ BONUS POINTS
      player.points += 200;
      PlayerStats.addPoints(200);
    }
  }

  function tryBuyDoor(door) {
  if (!door || door.open) return;
  if (player.points < door.cost) return;

  // Pay once
  player.points -= door.cost;
  PlayerStats.addDoorOpened?.();

  // Open this door + all linked doors
  const group = door.linkGroup ?? null;

  for (const d of doors) {
    if (d === door || (group && d.linkGroup === group)) {
      d.open = true;
    }
  }

  // üî• IMPORTANT: remove ALL door interacts immediately
  rebuildDoorInteracts();
}



  function resolveWallCollision(entity, wall) {
  resolveCircleWallCollision(entity, wall);
}

  
  
  

  // Points
  function awardHit() {
  const pts = 5;

  player.points += pts;        // ‚úÖ wallet
  PlayerStats.addPoints(pts);  // ‚úÖ lifetime stats
}


  function awardKill() {
    let pts = 100;
    PlayerStats.addPoints(pts);
    PlayerStats.addKill();

    if (activePowers.double) pts *= 2;
    player.points += pts;
  }
  function awardRepair() {
    let pts = 15;
    PlayerStats.addPoints(pts);
    if (activePowers.double) pts *= 2;
    player.points += pts;
  }

  // Barrier repair (single tick)
    function repairBarrierTick(b) {
  // ‚è±Ô∏è GLOBAL INTERACT COOLDOWN
  if (!canInteractNow()) return;

  const add = Math.ceil(b.hpMax * 0.10); // 10%
  const before = b.hp;

  // Allow rebuild from zero
  b.hp = clamp(b.hp + add, 0, b.hpMax);

  if (b.hp > before) {
    awardRepair();

    // ‚úÖ COMMIT INTERACTION ONLY IF REPAIR ACTUALLY HAPPENED
    markInteractUsed();
  }

  // Barrier is solid again as soon as HP > 0
  if (b.hp > 0) {
    b.open = false;
  }
}



  function getSlopeTriangle(wall) {
  const x = wall.x;
  const y = wall.y;
  const w = wall.w;
  const h = wall.h;

  if (wall.slope === 'left') {
    return [
      { x: x,     y: y + h },
      { x: x + w, y: y + h },
      { x: x,     y: y }
    ];
  }

  if (wall.slope === 'right') {
    return [
      { x: x,     y: y + h },
      { x: x + w, y: y + h },
      { x: x + w, y: y }
    ];
  }

  return null;
}


function pointInTriangle(px, py, tri) {
  const [a, b, c] = tri;

  function sign(p1, p2, p3) {
    return (p1.x - p3.x) * (p2.y - p3.y) -
           (p2.x - p3.x) * (p1.y - p3.y);
  }

  const d1 = sign({x: px, y: py}, a, b);
  const d2 = sign({x: px, y: py}, b, c);
  const d3 = sign({x: px, y: py}, c, a);

  const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
  const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

  return !(hasNeg && hasPos);
}



function resolveCircleTriangleCollision(circle, tri) {
  let collided = false;

  // --- EDGE COLLISION ---
  for (let i = 0; i < 3; i++) {
    const a = tri[i];
    const b = tri[(i + 1) % 3];

    const abx = b.x - a.x;
    const aby = b.y - a.y;

    const t = clamp(
      ((circle.x - a.x) * abx + (circle.y - a.y) * aby) /
      (abx * abx + aby * aby),
      0, 1
    );

    const px = a.x + abx * t;
    const py = a.y + aby * t;

    const dx = circle.x - px;
    const dy = circle.y - py;
    const dist = Math.hypot(dx, dy);

    if (dist < circle.radius) {
      const overlap = circle.radius - dist;
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);

      circle.x += nx * overlap;
      circle.y += ny * overlap;

      collided = true;
    }
  }

  // --- INSIDE TRIANGLE FIX (FLIP-SAFE) ---
  if (pointInTriangle(circle.x, circle.y, tri)) {
    let bestPen = Infinity;
    let pushX = 0;
    let pushY = 0;

    for (let i = 0; i < 3; i++) {
      const a = tri[i];
      const b = tri[(i + 1) % 3];

      const ex = b.x - a.x;
      const ey = b.y - a.y;

      // outward normal using triangle winding
      let nx = ey;
      let ny = -ex;

      const len = Math.hypot(nx, ny) || 1;
      nx /= len;
      ny /= len;

      const dist =
        (circle.x - a.x) * nx +
        (circle.y - a.y) * ny;

      // flip normal if pointing inward
      if (dist > 0) {
        nx = -nx;
        ny = -ny;
      }

      const pen = Math.abs(dist);

      if (pen < bestPen) {
        bestPen = pen;
        pushX = nx;
        pushY = ny;
      }
    }

    // push fully out
    circle.x += pushX * (circle.radius + bestPen);
    circle.y += pushY * (circle.radius + bestPen);

    collided = true;
  }

  return collided;
}



  function revivePlayer() {
    player.downed = false;
    player.alive = true;

    

    player.hitsRemaining = player.hitsMax;
    player.lastHitTime = performance.now(); // delay regen briefly after revive


    player.hitsRemaining = player.hitsMax;
    player.reviveTimer = 0;

    if (player.perks.quickRevive) {
      player.perks.quickReviveUsed = true;
    }
    
    if (player.perks.quickRevive) {
      player.quickRevive.level--;

      // quick revive consumed
      player.perks.quickRevive = false;

      if (player.quickRevive.level <= 0) {
        player.quickRevive.level = 0;
      }
    }

    // ===== REVIVE COMPLETE =====
    console.log("PLAYER REVIVED");

    player.downed = false;
    player.alive = true;

// Restore health
    player.hitsMax = player.perks.juggernog ? 7 : 4;
    player.hitsRemaining = player.hitsMax;

// Consume Quick Revive
    player.perks.quickReviveUsed = true;
    player.perks.quickRevive = false;

// üî• 5 SECONDS OF ZOMBIE FEAR
    player.zombieFearTimer = 15;

// Optional safety
    player.lastHitTime = performance.now();

  }




  function updateCamera() {
    const halfW = camera.w / (2 * camera.zoom);
    const halfH = camera.h / (2 * camera.zoom);

    camera.x = player.x - halfW;
    camera.y = player.y - halfH;

    // Clamp camera so it never shows outside the world
    camera.x = clamp(camera.x, 0, WORLD_WIDTH - halfW * 2);
    camera.y = clamp(camera.y, 0, WORLD_HEIGHT - halfH * 2);
  }


  // Interaction (E keydown): prioritize single repair tick, else buy
  function interact() {
    // 1Ô∏è‚É£ Barrier repair has priority
    const nb = nearestDamagedBarrier();
    if (nb) {
      repairBarrierTick(nb);
      return;
    }

    // 2Ô∏è‚É£ Only allow interacts within range
    const INTERACT_RANGE = 60;

    let nearest = null;
    let nd = INTERACT_RANGE;

    for (const i of interacts) {
      const d = Math.hypot(player.x - i.x, player.y - i.y);
      if (d < nd) {
        nd = d;
        nearest = i;
      }
    }

    if (nearest) {
      nearest.action(nearest);
    }
  }


  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'r') {
      startReload(player.currentGun);
    }
  });


  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k === 'e') interact();
    

  });

  function nearestDamagedBarrier() {
    let best = null;
    let bd = Infinity;

    for (const b of barriers) {
      if (b.hp >= b.hpMax) continue; // only skip FULL barriers

      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;
      const d = Math.hypot(player.x - cx, player.y - cy);

      if (d < 60 && d < bd) {
        bd = d;
        best = b;
      }
    }
    return best;
  }


  for (const d of doors) {
    if (!d.open) {
      resolveCircleWallCollision(player, d);
      for (const z of zombies) resolveCircleWallCollision(z, d);
    }
  }


  function drawSlopeWallGame(w) {
  const x1 = w.x - w.w / 2;
  const x2 = w.x + w.w / 2;
  const y1 = w.y - w.h / 2;
  const y2 = w.y + w.h / 2;

  ctx.fillStyle = '#555';
  ctx.beginPath();

  const flipped = w.flip === true;

  switch (w.slope) {

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LEFT SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'left':
      if (!flipped) {
        // normal
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x1, y1);
      } else {
        // flipped (upside down)
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x1, y2);
      }
      break;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RIGHT SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'right':
      if (!flipped) {
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x2, y1);
      } else {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x2, y2);
      }
      break;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UP SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'up':
      if (!flipped) {
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x2, y1);
      } else {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x1, y2);
      }
      break;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DOWN SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'down':
      if (!flipped) {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x1, y2);
      } else {
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x2, y1);
      }
      break;

    default:
      return;
  }

  ctx.closePath();
  ctx.fill();
}




  function resolveCircleSlopeCollision(entity, wall, r) {
  const x = wall.x - wall.w / 2;
  const y = wall.y - wall.h / 2;
  const w = wall.w;
  const h = wall.h;

  const flipped = wall.flip === true;

  // Define triangle points (MATCHES DRAW LOGIC)
  let tri;

  if (wall.slope === 'left') {
    if (!flipped) {
      // normal left slope
      tri = [
        { x: x,     y: y + h },
        { x: x + w, y: y + h },
        { x: x,     y: y }
      ];
    } else {
      // flipped left slope (upside down)
      tri = [
        { x: x,     y: y },
        { x: x + w, y: y },
        { x: x,     y: y + h }
      ];
    }
  }

  else if (wall.slope === 'right') {
    if (!flipped) {
      // normal right slope
      tri = [
        { x: x,     y: y + h },
        { x: x + w, y: y + h },
        { x: x + w, y: y }
      ];
    } else {
      // flipped right slope (upside down)
      tri = [
        { x: x,     y: y },
        { x: x + w, y: y },
        { x: x + w, y: y + h }
      ];
    }
  } else {
    return;
  }

  // Edge-by-edge circle vs triangle
  for (let i = 0; i < 3; i++) {
    const a = tri[i];
    const b = tri[(i + 1) % 3];

    const abx = b.x - a.x;
    const aby = b.y - a.y;

    const t = clamp(
      ((entity.x - a.x) * abx + (entity.y - a.y) * aby) /
      (abx * abx + aby * aby),
      0, 1
    );

    const px = a.x + abx * t;
    const py = a.y + aby * t;

    const dx = entity.x - px;
    const dy = entity.y - py;
    const dist = Math.hypot(dx, dy);

    if (dist < r) {
      const overlap = r - dist;
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);

      entity.x += nx * overlap;
      entity.y += ny * overlap;
    }
  }
}




  function resolveCircleWallCollision(entity, wall) {
  const r = entity.r || entity.radius || 12;

  // üî∫ SLOPE WALLS (TRIANGLES)
  if (wall.slope === 'left' || wall.slope === 'right') {
    resolveCircleSlopeCollision(entity, wall, r);
    return;
  }

  // üü¶ NORMAL RECT WALLS (unchanged logic)
  const left   = wall.x - wall.w / 2;
  const right  = wall.x + wall.w / 2;
  const top    = wall.y - wall.h / 2;
  const bottom = wall.y + wall.h / 2;

  const closestX = clamp(entity.x, left, right);
  const closestY = clamp(entity.y, top, bottom);

  const dx = entity.x - closestX;
  const dy = entity.y - closestY;

  const distSq = dx * dx + dy * dy;

  if (distSq < r * r) {
    const dist = Math.sqrt(distSq) || 0.0001;
    const overlap = r - dist;

    entity.x += (dx / dist) * overlap;
    entity.y += (dy / dist) * overlap;
  }
}



  // ---------- NEW: Collision helpers ----------
  // Prevent circular entities from entering solid (unbroken) barrier rectangles
  function resolveEntityBarrierCollision(entity, barrier) {
    if (barrier.open) return; // pass-through when broken
    const e = entity;
    const r = e.r || e.radius || 12;
    // Inflate barrier by entity radius for simple AABB collision
    const bx = barrier.x - r;
    const by = barrier.y - r;
    const bw = barrier.w + 2*r;
    const bh = barrier.h + 2*r;

    // If entity center is inside inflated rect, push to nearest edge
    if (e.x >= bx && e.x <= bx + bw && e.y >= by && e.y <= by + bh) {
      // Distances to edges
      const leftDist   = Math.abs(e.x - bx);
      const rightDist  = Math.abs((bx + bw) - e.x);
      const topDist    = Math.abs(e.y - by);
      const bottomDist = Math.abs((by + bh) - e.y);
      const minDist = Math.min(leftDist, rightDist, topDist, bottomDist);

      if (minDist === leftDist) {
        e.x = bx;
      } else if (minDist === rightDist) {
        e.x = bx + bw;
      } else if (minDist === topDist) {
        e.y = by;
      } else {
        e.y = by + bh;
      }
    }
  }


    function rectIntersect(a, b) {
      return (
        a.x - a.w / 2 < b.x + b.w / 2 &&
        a.x + a.w / 2 > b.x - b.w / 2 &&
        a.y - a.h / 2 < b.y + b.h / 2 &&
        a.y + a.h / 2 > b.y - b.h / 2
      );
    }


    function rayHitsWall(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const steps = Math.max(Math.abs(dx), Math.abs(dy)) * 2;
  const stepX = dx / steps;
  const stepY = dy / steps;

  for (let i = 0; i <= steps; i++) {
    const px = x1 + stepX * i;
    const py = y1 + stepY * i;

    // Check walls (assuming w.x, w.y are center coordinates)
    for (const w of walls) {
      const left = w.x - w.w / 2;
      const right = w.x + w.w / 2;
      const top = w.y - w.h / 2;
      const bottom = w.y + w.h / 2;

      if (px > left && px < right && py > top && py < bottom) {
        return true;
      }
    }

    // Check barriers (rectangular, top-left origin)
    for (const b of barriers) {
      if (b.open) continue;
      if (px > b.x && px < b.x + b.w && py > b.y && py < b.y + b.h) {
        return true;
      }
    }

    // Check doors (rectangular, top-left origin)
    for (const d of doors) {
      if (d.open) continue;
      if (px > d.x && px < d.x + d.w && py > d.y && py < d.y + d.h) {
        return true;
      }
    }
  }

  return false;
}


  




  function drawWeaponHUD() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const padding = 50;
  const hudW = 200;
  const hudH = 90;

  const x = canvas.width - hudW - padding;
  const y = canvas.height - hudH - padding;

  ctx.save();

  // ===============================
  // ‚ù§Ô∏è HEALTH BAR (ALWAYS DRAWS)
  // ===============================
  const barWidth = hudW - 30;
  const barHeight = 10;
  const barX = x + 15;
  const barY = y + hudH + 10;

  const healthPct = Math.max(
    0,
    Math.min(1, player.hitsRemaining / player.hitsMax)
  );

  // background
  ctx.fillStyle = '#222';
  ctx.fillRect(barX, barY, barWidth, barHeight);

  // color based on health
  if (healthPct <= 0.3) {
    ctx.fillStyle = '#e74c3c'; // red
  } else if (healthPct <= 0.6) {
    ctx.fillStyle = '#f1c40f'; // yellow
  } else {
    ctx.fillStyle = '#2ecc71'; // green
  }

  // fill
  ctx.fillRect(barX, barY, barWidth * healthPct, barHeight);

  // border
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  ctx.strokeRect(barX, barY, barWidth, barHeight);

  // ===============================
  // üî´ WEAPON HUD (SAFE TO EXIT)
  // ===============================
  const g = player.currentGun;
  if (!g) {
    ctx.restore();
    return;
  }

  // üî¥ Blood streak background
  ctx.fillStyle = '#8b0000';
  ctx.beginPath();
  ctx.moveTo(x + 22, y);
  ctx.lineTo(x + hudW, y);
  ctx.lineTo(x + hudW - 22, y + hudH);
  ctx.lineTo(x, y + hudH);
  ctx.closePath();
  ctx.fill();

  // üî´ AMMO (CENTER)
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 36px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const ammo = g.mag === Infinity ? '‚àû' : g.mag;
  ctx.fillText(ammo, x + hudW / 2, y + hudH / 2 - 6);

  // üßÆ RESERVE
  if (g.mag !== Infinity) {
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#ddd';
    ctx.fillText(
      g.reserve,
      x + hudW / 2 + 55,
      y + hudH / 2 - 6
    );
  }

    // üí£ GRENADES (UNDER RESERVE)
  if (typeof player.grenades === 'number') {
    ctx.font = '14px sans-serif';
    ctx.fillStyle = '#ffb347'; // soft orange

    ctx.fillText(
      `üí£ ${player.grenades}`,
      x + hudW / 2 + 55,
      y + hudH / 2 + 14
    );
  }




  // ‚≠ê UPGRADE LEVEL
  if (g.upgradeLevel && g.upgradeLevel > 0) {
    ctx.font = 'bold 13px sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.fillText(
      `UPG ${g.upgradeLevel}`,
      x + hudW / 2,
      y + hudH - 30
    );
  }

  // üî§ GUN NAME
  ctx.font = '14px sans-serif';
  ctx.fillStyle = '#eee';
  ctx.fillText(
    g.name.toUpperCase(),
    x + hudW / 2,
    y + hudH - 15
  );

  ctx.restore();
}

function drawLowHealthVignette(ctx, healthPct) {
  // Full health = no effect
  if (healthPct >= 1) return;

  // How close to death (0 ‚Üí 1)
  const danger = 1 - healthPct;

  // Max opacity caps (tweak if desired)
  const maxAlpha = 0.75;

  const alpha = danger * maxAlpha;

  const w = ctx.canvas.width;
  const h = ctx.canvas.height;

  const cx = w / 2;
  const cy = h / 2;
  const innerRadius = Math.min(w, h) * (0.35 + healthPct * 0.15);
  const outerRadius = Math.max(w, h) * 0.75;

  const grad = ctx.createRadialGradient(
    cx, cy, innerRadius,
    cx, cy, outerRadius
  );

  grad.addColorStop(0, `rgba(255, 0, 0, 0)`);
  grad.addColorStop(1, `rgba(180, 0, 0, ${alpha})`);

  ctx.save();
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, w, h);
  ctx.restore();
}


  function drawPointsHUD() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    const paddingX = 50;
    const paddingY = 50;

    const hudW = 145;
    const hudH = 40;

  // position ABOVE weapon HUD
    const weaponHudH = 90;
    const gap = 10;

    const x = canvas.width - hudW - paddingX;
    const y = canvas.height - weaponHudH - hudH - paddingY - gap;

    ctx.save();

  // üî¥ Blood streak background (smaller)
    ctx.fillStyle = '#8b0000';
    ctx.beginPath();
    ctx.moveTo(x + 18, y);
    ctx.lineTo(x + hudW, y);
    ctx.lineTo(x + hudW - 18, y + hudH);
    ctx.lineTo(x, y + hudH);
    ctx.closePath();
    ctx.fill();

    // üí∞ Points value
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.fillText(
      player.points,
      x + hudW / 2,
      y + hudH / 2.5
    );

    // Optional label
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#eee';
    ctx.fillText(
    'SUS',
      x + hudW / 2,
      y + hudH - 7
    );

    ctx.restore();
  }




    function resolvePlayerBarrierCollision(player, barrier) {
      const r = player.radius;

      // Closest point on rectangle to player center
      const closestX = clamp(player.x, barrier.x, barrier.x + barrier.w);
      const closestY = clamp(player.y, barrier.y, barrier.y + barrier.h);

      const dx = player.x - closestX;
      const dy = player.y - closestY;

      const distSq = dx * dx + dy * dy;

      // If overlapping
      if (distSq < r * r) {
        const dist = Math.sqrt(distSq) || 0.0001;
        const overlap = r - dist;

        // Push player out along collision normal
        player.x += (dx / dist) * overlap;
        player.y += (dy / dist) * overlap;
      }
    }

    function resolveAllBarrierCollisionsForEntity(entity, canPassWhenOpen) {
      for (const b of barriers) {
        if (b.open && canPassWhenOpen) continue;

        const r = entity.r || entity.radius || 12;

        const closestX = clamp(entity.x, b.x, b.x + b.w);
        const closestY = clamp(entity.y, b.y, b.y + b.h);

        const dx = entity.x - closestX;
        const dy = entity.y - closestY;

        const distSq = dx * dx + dy * dy;
        if (distSq < r * r) {
          const dist = Math.sqrt(distSq) || 0.0001;
          const overlap = r - dist;

          entity.x += (dx / dist) * overlap;
          entity.y += (dy / dist) * overlap;
        }

        for (const z of zombies) {
          for (const b of barriers) {
            if (!b.open) {
              resolveCircleRotatedRectCollision(zombie, b);
              resolveEntityBarrierCollision(z, b);
              checkZombiePassedBarrier(z, b);
            }
          }
        }


        for (const b of barriers) {
          if (!b.open) {
            resolveCircleRotatedRectCollision(player, b);
          }
        }

      }
    }

    function clampCamera() {
      const halfW = camera.w / (2 * camera.zoom);
      const halfH = camera.h / (2 * camera.zoom);

      camera.x = Math.max(halfW, Math.min(WORLD_WIDTH - halfW, camera.x));
      camera.y = Math.max(halfH, Math.min(WORLD_HEIGHT - halfH, camera.y));
}


  function maybeDropPowerUp(x, y) {
    // Base drop chance (classic zombies feel)
    if (Math.random() > 0.00095) return; // 15% overall drop chance

    const rarity = rollDropRarity(round);
    if (!rarity) return;

    const pool = DROP_RARITIES[rarity].drops;
    const type = pool[Math.floor(Math.random() * pool.length)];

    powerDrops.push({
     x,
      y,
      r: 16,
      type,
      rarity,
      spawnTime: performance.now()
    });
  }


  // -------------------------------------------


  
  // Game loop timing
  let lastTime = performance.now();
  let now = lastTime;

  // Start first round
  startRoundSpawns();
  RoundMusic.playStart();

  function update(dt) {
    // Update player aim
    const mw = getMouseWorldPos();
    const mouseWorldX = mouse.x + camera.x;
    const mouseWorldY = mouse.y + camera.y;
    const now = performance.now();

    const worldMouse = screenToWorld(mouse.x, mouse.y);
    player.angle = Math.atan2(worldMouse.y - player.y, worldMouse.x - player.x);
    


    updateReloads(dt);
    updateHealthRegen(dt);
    updatePowerDrops(now);
    updateGrenades(dt);



    
// ===============================
// DOWNED / QUICK REVIVE SYSTEM
// ===============================
if (player.downed) {
  // countdown (dt is already seconds)
  player.reviveTimer -= dt;
  resetAllPerkEffects();

  // clamp
  if (player.reviveTimer < 0) player.reviveTimer = 0;

  // finished reviving
  if (player.reviveTimer === 0) {
    revivePlayer();
  }

  // stop all movement / combat while downed
  return;
}


// ENTER DOWNED STATE (run ONCE)
// ===== PLAYER DOWNED LOGIC (FIXED) =====
if (player.hitsRemaining <= 0 && !player.downed) {

  // QUICK REVIVE AVAILABLE
  if (player.perks.quickRevive && !player.perks.quickReviveUsed) {

    player.downed = true;
    player.alive = false;
    
    // üî• START REVIVE
    player.reviveDuration = 5;
    player.reviveTimer = player.reviveDuration;
    PlayerStats.addDown();



  } else {
    // NO QUICK REVIVE ‚Üí GAME OVER
    player.alive = false;
    PlayerStats.addDown();
    gameOver();
  }
}







// ===== QUICK REVIVE TIMER =====
    if (player.downed) {

      player.reviveTimer -= dt;
      resetAllPerkEffects();

      if (player.reviveTimer <= 0) {

        // üî• STAND BACK UP
        player.downed = false;
        player.alive = true;

        // Restore health
        player.hitsMax = player.perks.juggernog ? 5 : 3;

    // Consume Quick Revive
        player.perks.quickReviveUsed = true;
        player.perks.quickRevive = false;

    // Safety reset
        player.reviveTimer = 0;
  }

      return; // ‚õî Skip normal gameplay while downed
    }


    // ===== POWER-UP TIMERS =====
    if (activePowers.insta && now > activePowers.timers.insta) {
      activePowers.insta = false;
    }

    if (activePowers.double && now > activePowers.timers.double) {
      activePowers.double = false;
    }

    if (activePowers.death && now > activePowers.timers.death) {
      activePowers.death = false;

      // restore previous gun
      if (player.prevGunBeforeDeath) {
        player.currentGun = player.prevGunBeforeDeath;
        player.prevGunBeforeDeath = null;
      }
    }

    

    // üö™ PLAYER vs DOORS
    for (const d of doors) {
      if (!d.open) {
        resolveCircleRotatedRectCollision(player, d);
      }
    }


    // Zombies vs walls
    for (const z of zombies) {
      if (!z.alive) continue;
      
      for (const d of doors) {
        if (!d.open) {
          resolveCircleWallCollision(z, d);
        }
      }


      for (const w of walls) {
        resolveCircleWallCollision(z, w);
      }
      // üö™ ZOMBIE vs DOORS
      for (const d of doors) {
        if (!d.open) {
          resolveCircleRotatedRectCollision(z, d);
        }
      }
      handleZombieStuck(z, dt);
    }

    

    // Player vs walls
// Player vs walls
for (const wall of walls) {

  if (wall.slope) {
    // üî∫ slope collision (player)
    const rPlayer = player.r || player.radius || 12;
    resolveCircleSlopeCollision(player, wall, rPlayer);

    // üßü zombies (WITH BOOST)
    for (const z of zombies) {
      resolveZombieWallCollisionWithBoost(z, wall);
    }

  } else {
    // üß± normal wall collision (player)
    resolveWallCollision(player, wall);

    // üßü zombies (WITH BOOST)
    for (const z of zombies) {
      resolveZombieWallCollisionWithBoost(z, wall);
    }
  }
}

  // Add this inside the update(dt) function, after the existing collision resolution code
// Zombie-to-zombie collision resolution (handles both regular and boss zombies)
for (let i = 0; i < zombies.length; i++) {
  const z1 = zombies[i];
  if (!z1.alive) continue;
  
  for (let j = i + 1; j < zombies.length; j++) {
    const z2 = zombies[j];
    if (!z2.alive) continue;
    
    const dx = z2.x - z1.x;
    const dy = z2.y - z1.y;
    const dist = Math.hypot(dx, dy);
    const minDist = (z1.r || z1.radius || 12) + (z2.r || z2.radius || 12);
    
    if (dist < minDist && dist > 0) {
      // Separate the zombies
      const overlap = minDist - dist;
      const nx = dx / dist;
      const ny = dy / dist;
      
      // Move zombies apart (heavier zombies move less)
      const totalMass = (z1.hpMax || 100) + (z2.hpMax || 100);
      const ratio1 = (z2.hpMax || 100) / totalMass;
      const ratio2 = (z1.hpMax || 100) / totalMass;
      
      z1.x -= nx * overlap * ratio1 * 0.5;
      z1.y -= ny * overlap * ratio1 * 0.5;
      z2.x += nx * overlap * ratio2 * 0.5;
      z2.y += ny * overlap * ratio2 * 0.5;
    }
  }
}


    // Handle round cooldown timer
    if (roundCooldown && now >= roundCooldownEnd) {
      roundCooldown = false;
      showRoundBanner = false;
      RoundMusic.playStart();
      startRoundSpawns();
      
    }

    for (const z of zombies) {
  for (const b of barriers) {
    // Resolve collision between zombie and barrier
    resolveEntityBarrierCollision(z, b);
    checkZombiePassedBarrier(z, b);

    // Barrier timeout check: if zombie spawned behind barrier and should ignore barriers now
    if (z.spawnedBehindBarrier && shouldZombieIgnoreBarriers(z)) {
      z.spawnedBehindBarrier = false;
      z.targetBarrier = null;
      z.blockedByBarrier = null;
    }

    // Boss zombies ignore all barriers
    if (z.isBoss) continue;

    // Ignore broken/open barriers
    if (b.hp <= 0 || b.open) continue;

    // Check collision between zombie circle and barrier rectangle
    if (
      rectCircleCollide(
        z.x, z.y, z.r,
        b.x, b.y, b.w, b.h
      )
    ) {
      // Calculate barrier center
      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;

      // Vector from barrier center to zombie
      const dx = z.x - cx;
      const dy = z.y - cy;

      // Calculate overlap distances on X and Y axes
      const overlapX = b.w / 2 + z.r - Math.abs(dx);
      const overlapY = b.h / 2 + z.r - Math.abs(dy);

      // Push zombie out along the axis with the least overlap
      if (overlapX < overlapY) {
        z.x += dx > 0 ? overlapX : -overlapX;
      } else {
        z.y += dy > 0 ? overlapY : -overlapY;
      }

      // Mark zombie as blocked by this barrier to stop movement
      z.blockedByBarrier = b;
    }
  }
}

    for (const t of zombieTraps) {

  // ‚è≥ delayed activation
  if (t.pending && now >= t.activateAt) {
    t.pending = false;
    t.active = true;
    t.activeUntil = now + t.duration * 1000;
  }

  // ‚è±Ô∏è auto shutoff ‚Üí cooldown
  if (t.active && now >= t.activeUntil) {
    t.active = false;
    t.cooldownUntil = now + t.cooldown * 1000;
    continue;
  }

  // ‚õî cooldown lock
  if (now < t.cooldownUntil) continue;

  // ‚õî inactive
  if (!t.active) continue;

  // üî• zombies
  for (const z of zombies) {
    if (!z.alive) continue;

    // üîí one-time safety init
    if (z.killedByTrap == null) z.killedByTrap = false;
    if (z.killedByTrap) continue;

    if (
      circleRectHit(
        z.x, z.y, z.r,
        t.x - t.w / 2,
        t.y - t.h / 2,
        t.w,
        t.h
      )
    ) {
      z.alive = false;
      z.killedByTrap = true;

      const pts = 25;
      player.points += pts;

      // üìä STATS (ONCE)
      PlayerStats.addPoints(pts);
      PlayerStats.addKill();
      PlayerStats.addTrapKill();
    }
  }


  // ‚ò†Ô∏è PLAYER DAMAGE FROM TRAP
  if (
    circleRectHit(
     player.x, player.y, player.radius,
      t.x - t.w / 2,
      t.y - t.h / 2,
      t.w,
      t.h
    )
  ) {
    if (now >= player.trapDamageImmunityUntil) {

      player.trapDamageImmunityUntil = now + 300;
      player.lastHitTime = now;

      if (player.perks.juggernog) {
      // üî• NEW RULE
        if (player.hitsRemaining < 7) {
          player.hitsRemaining = 0; // instant down
        } else {
          player.hitsRemaining = 1; // barely survive
        }
      } else {
        player.hitsRemaining = 0;
      }

    }
  }
      }




    function updateReloads(dt) {
      const g = player.currentGun;
      if (!g || !g.reloading) return;

      g.reloadTimer -= dt;

      if (g.reloadTimer > 0) return;

      const needed = g.magMax - g.mag;
      const taken = Math.min(needed, g.reserve);

      g.mag += taken;
      g.reserve -= taken;

      g.reloading = false;
      g.reloadTimer = 0;
    }



    // Downed / revive handling: block movement & shooting, count down timer
    // ===== DOWNED LOGIC =====
  // ===== DOWNED / REVIVE LOGIC (FIXED) =====
// ===== DOWNED / QUICK REVIVE LOGIC (FINAL FIX) =====




    
    // Movement
    let vx=0, vy=0;
    if (keys['w']) vy -= 1;
    if (keys['s']) vy += 1;
    if (keys['a']) vx -= 1;
    if (keys['d']) vx += 1;
    if (vx !== 0 || vy !== 0) {
      const len = Math.hypot(vx,vy);
      vx /= len; vy /= len;
    }
    

    //---
    const speed = player.speed;
    updateReloads(dt);

    // save previous position (used by collision resolution)
    player.prevX = player.x;
    player.prevY = player.y;

    // APPLY MOVEMENT
    player.x += vx * speed * dt;
    player.y += vy * speed * dt;

    // CLAMP TO WORLD (not screen)
    player.x = clamp(player.x, 20, WORLD_WIDTH - 20);
    player.y = clamp(player.y, 20, WORLD_HEIGHT - 20);


    player.x = clamp(player.x, 20, WORLD_WIDTH - 20);
    player.y = clamp(player.y, 20, WORLD_HEIGHT - 20);


    // ---------- NEW: Zombie vs Zombie collision ----------
    // Inside the update(dt) function in zombies.html

// ---- Zombie vs Zombie collision resolution ----
for (let i = 0; i < zombies.length; i++) {
  const z1 = zombies[i];
  if (!z1.alive) continue;

  for (let j = i + 1; j < zombies.length; j++) {
    const z2 = zombies[j];
    if (!z2.alive) continue;

    // This function calculates the overlap and pushes both zombies apart
    resolveCircleCollision(z1, z2);
  }
}

    

    

// ---------------------------------------------------

    // ---------- NEW: Player vs barrier collision ----------
    for (const b of barriers) {resolvePlayerBarrierCollision(player, b);}


    // ------------------------------------------------------

    // Shooting / reload
    const g = player.currentGun;
    if (g) {
      if (g.cooldown > 0) g.cooldown = Math.max(0, g.cooldown - dt);
      if (mouse.down) {
        if (g.auto) shoot(); else { shoot(); mouse.down = false; }
      }
    }

    // Health regen after 15s no hit
    const regenDelay = 15000 / player.quickRevive.regenMultiplier;



    // Hold E to repair: 10% per second up to 10 seconds per hold
    if (keys['e']) {
  const b = nearestDamagedBarrier();
  const now = performance.now();

  if (
    b &&
    b.hp > 0 &&
    b.hp < b.hpMax &&
    canInteractNow() // ‚è±Ô∏è GLOBAL INTERACT COOLDOWN
  ) {
    repairBarrierTick(b);

    // ‚úÖ COMMIT INTERACTION
    markInteractUsed();

    // (Optional) keep local timestamp if you still want it for UI
    player.repairing.lastRepairTime = now;
  }
}





    // Update barriers open state
    for (const b of barriers) b.open = (b.hp <= 0);

    // Batch spawns
    if (!roundCooldown && spawnRemaining > 0) {
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        const batch = Math.min(spawnRemaining, Math.floor(rnd(2,4)));
        spawnBatch(roundZombieHP(round), batch);
        spawnRemaining -= batch;
        spawnTimer = rnd(1.0, 2.5);
      }
    }

    // Update zombies


    


  

    aliveCount = 0;
    for (const z of zombies) {
  if (!z.alive) continue;

  // upkeep + attacks
  clearBarrierIfPassed(z);
  handleZombieAttacks(z, now);
  aliveCount++;
  z.skipMove = false;

  // ===============================
  // MONKEY BOMB OVERRIDE (HARD OVERRIDE)
  // ===============================
  if (z.forcedTarget) {
    // Ignore ALL blockers
    z.skipMove = false;
    z.blockedByBarrier = null;

    const dx = z.forcedX - z.x;
    const dy = z.forcedY - z.y;
    const dist = Math.hypot(dx, dy) || 1;

    const nx = dx / dist;
    const ny = dy / dist;

    // üî• DIRECT POSITION MOVE (bypasses freeze bugs)
    z.x += nx * z.speed * dt;
    z.y += ny * z.speed * dt;

    // Optional facing
    z.angle = Math.atan2(ny, nx);

    handleZombieStuck(z, dt);
    continue; // ‚õî skip ALL other logic
  }

  // ===============================
  // NORMAL TARGETING LOGIC
  // ===============================
  let targetX = player.x;
  let targetY = player.y;

  const dxp = player.x - z.x;
  const dyp = player.y - z.y;
  const distPlayer = Math.hypot(dxp, dyp);

  const fearing = player.zombieFearTimer > 0;

  if (fearing) {
    // Run away from player
    const dx = z.x - player.x;
    const dy = z.y - player.y;
    const len = Math.hypot(dx, dy) || 1;

    targetX = z.x + (dx / len) * 100;
    targetY = z.y + (dy / len) * 100;
  } else {
    targetX = player.x;
    targetY = player.y;
  }

  let chasingPlayer = true;

  // ===============================
// BARRIER LOGIC (optimized: use closest point on rect + early bailouts)
// ===============================
const MAX_BARRIER_CHECK_DIST = 200; // max distance to consider barrier for a zombie

for (const z of zombies) {
  if (!z.alive) continue;

  // Precompute distance to player once
  const distPlayer = Math.hypot(player.x - z.x, player.y - z.y);

  // Filter barriers by distance first to reduce checks
  const nearbyBarriers = barriers.filter(b => {
    if (b.hp <= 0 || b.open) return false;
    // Approximate barrier center
    const bx = b.x + b.w / 2;
    const by = b.y + b.h / 2;
    const dist = Math.hypot(z.x - bx, z.y - by);
    return dist < MAX_BARRIER_CHECK_DIST;
  });

  let assignedBarrier = null;

  for (const b of nearbyBarriers) {
    // resolve collision and pass checks as before
    resolveEntityBarrierCollision(z, b);
    checkZombiePassedBarrier(z, b);

    // Barrier timeout check
    if (z.spawnedBehindBarrier && shouldZombieIgnoreBarriers(z)) {
      z.spawnedBehindBarrier = false;
      z.targetBarrier = null;
      z.blockedByBarrier = null;
    }

    // Boss zombies ignore all barriers
    if (z.isBoss) continue;

    // Closest point on barrier rect to zombie
    const bxClosest = clamp(z.x, b.x, b.x + b.w);
    const byClosest = clamp(z.y, b.y, b.y + b.h);
    const distBarrier = Math.hypot(z.x - bxClosest, z.y - byClosest);

    // Only check rayHitsWall if zombie is close enough and barrier is between zombie and player roughly
    let barrierBlocksLOS = false;
    if (distBarrier < distPlayer) {
      // Simple bounding box check: is barrier roughly between zombie and player?
      const minX = Math.min(z.x, player.x);
      const maxX = Math.max(z.x, player.x);
      const minY = Math.min(z.y, player.y);
      const maxY = Math.max(z.y, player.y);
      if (b.x < maxX && b.x + b.w > minX && b.y < maxY && b.y + b.h > minY) {
        barrierBlocksLOS = rayHitsWall(z.x, z.y, player.x, player.y);
      }
    }

    if (z.spawnedBehindBarrier || barrierBlocksLOS) {
      assignedBarrier = b;
      z.targetBarrier = b;
    }

    // If this zombie is assigned to this barrier, attempt to attack when in range
    if (z.targetBarrier === b) {
      // Bias: make attack range a bit larger for very flat (horizontal) barriers
      const flatness = b.w > b.h ? (b.w / Math.max(1, b.h)) : 1;
      const extraRange = flatness > 3 ? 6 : 2; // larger buffer for very wide low barriers
      const attackRange = (z.attackRange ?? (z.r + 6)) + extraRange;

      // Also allow attacking if physically overlapping (collision) even if dist slightly larger
      const overlapping = rectCircleCollide(z.x, z.y, z.r, b.x, b.y, b.w, b.h);

      // Only attack if barrier is blocking the path or zombie spawned behind it
      if ((z.spawnedBehindBarrier || barrierBlocksLOS) && (distBarrier <= attackRange || overlapping)) {
        // mark blocked so movement code can stop movement
        z.blockedByBarrier = b;
        z.skipMove = true;

        // initialize hit interval if missing
        if (z.barrierHitInterval == null) z.barrierHitInterval = 0.3;
        if (z.barrierHitCooldown == null) z.barrierHitCooldown = 0;

        z.barrierHitCooldown -= dt;
        if (z.barrierHitCooldown <= 0) {
          // apply one hit (damage per hit stored in z.attackBarrierDps)
          b.hp -= z.attackBarrierDps;
          // reset cooldown to the configured interval
          z.barrierHitCooldown = z.barrierHitInterval;

          if (b.hp <= 0) {
            b.hp = 0;
            b.open = true;
            z.blockedByBarrier = null;
            // once open, clear target so zombie goes back to player
            if (z.targetBarrier === b) z.targetBarrier = null;
          }
        }
      }
    }

    // If there's a physical collision (z inside barrier bounds), push out as before
    if (
      rectCircleCollide(
        z.x, z.y, z.r,
        b.x, b.y, b.w, b.h
      )
    ) {
      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;

      const dx = z.x - cx;
      const dy = z.y - cy;

      const overlapX = b.w / 2 + z.r - Math.abs(dx);
      const overlapY = b.h / 2 + z.r - Math.abs(dy);

      if (overlapX < overlapY) {
        z.x += dx > 0 ? overlapX : -overlapX;
      } else {
        z.y += dy > 0 ? overlapY : -overlapY;
      }

      // STOP zombie movement when colliding
      z.blockedByBarrier = b;
      z.skipMove = true;
    }
  }

  // If no barrier assigned, clear targetBarrier
  if (!assignedBarrier) {
    z.targetBarrier = null;
  }

  // If barrier not chosen/attacked, ensure primary target remains player
  if (chasingPlayer) {
    targetX = player.x;
    targetY = player.y;
    z.blockedByBarrier = null;
  }

  // ===============================
// FINAL MOVEMENT (Last Zombie Sprint)
// ===============================
if (!z.skipMove) {
  // 1. Base Speed: Use the zombie's individual speed
  let baseSpeed = z.speed;

  // 2. Last Zombie Sprint: If this is the only zombie left, make it faster
  const aliveZombies = zombies.filter(zombie => zombie.alive).length;
  if (aliveZombies === 1) {
    baseSpeed *= 8.0; // 80% speed boost for the last zombie
  }

  // 3. Desired direction -> normalized
  let dx = targetX - z.x;
  let dy = targetY - z.y;
  let dist = Math.hypot(dx, dy) || 0.0001;
  let dirX = dx / dist;
  let dirY = dy / dist;

  // 4. Wall avoidance: cast multiple short rays around the zombie
  const avoidForce = { x: 0, y: 0 };
  const rayCount = 8;
  const rayLength = 25;

  for (let i = 0; i < rayCount; i++) {
    const angle = (i / rayCount) * Math.PI * 2;
    const rx = z.x + Math.cos(angle) * rayLength;
    const ry = z.y + Math.sin(angle) * rayLength;

    if (rayHitsWall(z.x, z.y, rx, ry)) {
      // push away from wall direction
      avoidForce.x -= Math.cos(angle);
      avoidForce.y -= Math.sin(angle);
    }
  }

  // 5. Combine movement and avoidance (reduced avoid weight to prioritize chasing)
  const avoidWeight = 0.4;
  let moveX = dirX + avoidForce.x * avoidWeight;
  let moveY = dirY + avoidForce.y * avoidWeight;
  let moveLen = Math.hypot(moveX, moveY) || 0.0001;
  moveX /= moveLen;
  moveY /= moveLen;

  // 6. Wall speed boost mechanics (smoother boost and decay)
  if (z.wallSpeedBoost == null) z.wallSpeedBoost = 1;
  if (z.wallBoostTimer == null) z.wallBoostTimer = 0;

  if (z.wallBoostTimer > 0) {
    z.wallBoostTimer -= dt * 1000;
    z.wallSpeedBoost = Math.min(2.5, z.wallSpeedBoost + dt * 1.5);
  } else {
    z.wallSpeedBoost = Math.max(1, z.wallSpeedBoost - dt * 0.5);
  }

  const boost = z.wallSpeedBoost;

  z.vx = moveX * baseSpeed * boost;
  z.vy = moveY * baseSpeed * boost;

  // apply movement
  z.x += z.vx * dt;
  z.y += z.vy * dt;

  // optional facing
  z.angle = Math.atan2(z.vy, z.vx);
}

// reset skip flag for next frame
z.skipMove = false;

// stuck detection / recovery
handleZombieStuck(z, dt);

// resolve collisions with player
resolveCircleCollision(player, z);
}


      if (player.zombieFearTimer > 0) {
        player.zombieFearTimer -= dt;
        if (player.zombieFearTimer < 0) {
          player.zombieFearTimer = 0;
        }
      }


      // ---------- Zombie Fear (unchanged) ----------
      // ---------- Zombie Fear (FIXED) ----------
      if (player.zombieFearTimer > 0) {

        // Run directly away from player
        const dx = z.x - player.x;
        const dy = z.y - player.y;
        const len = Math.hypot(dx, dy) || 1;

        const fleeSpeed = z.speed * 1.1; // slight boost, optional

        z.x += (dx / len) * fleeSpeed * dt;
        z.y += (dy / len) * fleeSpeed * dt;

      } else {
        // Normal zombie behavior continues below
      }


      // ===============================
      // ‚ù§Ô∏è HEALTH REGEN SYSTEM
      // ===============================
      if (
        player.alive &&
        !player.downed &&
        player.hitsRemaining < player.hitsMax
      ) {
        const now = performance.now();

        if (now - player.lastHitTime >= player.regenDelay) {
          const regenAmount = player.regenRate * (dt / 1000);
          player.hitsRemaining = Math.min(
          player.hitsMax,
          player.hitsRemaining + regenAmount
        );
      }
    }


      // ---------- Move toward chosen target ----------
if (!z.skipMove) {
  const dx = targetX - z.x;
  const dy = targetY - z.y;
  const dist = Math.hypot(dx, dy);

  // üî• Safety init (no spawn changes needed)
  if (z.wallSpeedBoost == null) z.wallSpeedBoost = 1;
  if (z.wallBoostTimer == null) z.wallBoostTimer = 0;

  // üîª Decay wall boost when not refreshing
  if (z.wallBoostTimer > 0) {
    z.wallBoostTimer -= dt * 1000;
  } else {
    z.wallSpeedBoost = Math.max(1, z.wallSpeedBoost - dt * 2);
  }

  if (dist > 0) {
    const boost = Math.min(3, z.wallSpeedBoost);

    z.x += (dx / dist) * z.speed * boost * dt;
    z.y += (dy / dist) * z.speed * boost * dt;
  }
}


      z.skipMove = false;


      resolveCircleCollision(player, z);

      // ---- NEW: Zombie vs barrier collision ----
if (z.blockedByBarrier && !z.isBoss) {
  z.barrierHitCooldown -= dt;

  if (z.barrierHitCooldown <= 0) {
    z.blockedByBarrier.hp -= z.attackBarrierDps;
    z.barrierHitCooldown = 1.5;

    if (z.blockedByBarrier.hp <= 0) {
      z.blockedByBarrier.hp = 0;
      z.blockedByBarrier.open = true;
    }
  }

  continue; // DO NOT MOVE THROUGH
}

// ---- Boss zombies should never be blocked ----
if (z.isBoss) {
  z.blockedByBarrier = null;
}

// ----

// If near player, deal hits intermittently
const playerReach = z.isBoss ? 40 : 26; // Bigger reach for boss zombies
const d2p = Math.hypot(z.x - player.x, z.y - player.y);
if (player.downed) continue;

if (d2p <= playerReach) {
    z.playerHitCooldown -= dt;

    if (z.playerHitCooldown <= 0) {
        if (player.downed) continue;
        // ‚õî ignore zombie damage briefly after trap hit
        if (now < player.trapDamageImmunityUntil) continue;

        // Boss zombies deal more damage
        const damage = z.isBoss ? BOSS_CONFIG.damageMultiplier : 1;
        player.hitsRemaining -= damage;
        player.lastHitTime = performance.now();

        z.playerHitCooldown = z.isBoss ? 0.4 : 0.5; // Bosses attack slightly faster
    }
}}

    // Round progression
    // Round progression
    if (aliveCount === 0 && spawnRemaining === 0 && !roundCooldown) {
      round += 1;
      startRoundCooldown();
      RoundMusic.playEnd();
      PlayerStats.addRoundSurvived();
      player.grenades = Math.min(
        player.grenades + 2,
        player.grenadesMax
      );

    }


    //----------------
    camera.x = clamp(
      player.x - camera.w / 2,
      0,
      WORLD_WIDTH - camera.w
    );

    camera.y = clamp(
      player.y - camera.h / 2,
      0,
      WORLD_HEIGHT - camera.h
    );

    // ---------- BULLETS ----------
    for (const bullet of bullets) {
      bullet.x += bullet.vx * dt;
      bullet.y += bullet.vy * dt;
      bullet.life -= dt;
    }

    // ---------- BULLET vs ZOMBIE DAMAGE ----------
    for (const bullet of bullets) {
      if (bullet.life <= 0) continue;

      for (const z of zombies) {
        if (!z.alive) continue;

        const dx = bullet.x - z.x;
        const dy = bullet.y - z.y;
        const hitDist = z.r + 2;

        if (dx * dx + dy * dy <= hitDist * hitDist) {
          // ‚úÖ DAMAGE APPLIED
          const dmg = activePowers.insta ? z.hp : bullet.damage;
          z.hp -= dmg;
          bullet.life = 0;

          if (z.hp <= 0) {
  z.alive = false;
  awardKill();
  
  // Boss kill rewards
  if (z.isBoss) {
    player.points += 690; // Bonus points for boss
    PlayerStats.addPoints(690);
    PlayerStats.addBossKill();
    
    // Check if last boss - drop max ammo
    const bossesAlive = zombies.filter(zz => zz.alive && zz.isBoss).length;
    if (bossesAlive === 0 && isBossRound) {
      // Drop MAX AMMO
      powerDrops.push({
        type: 'MAX',
        x: z.x,
        y: z.y,
        r: 16,
        spawnedAt: performance.now(),
        lifetime: 30000
      });
    }
  } else {
    tryDropPower(z.x, z.y);
    maybeDropPowerUp(z.x, z.y);
  }
}
          break;
        }
      }
    }

    // remove dead bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      let hitWall = false;

      // ---- SOLID WALLS ----
      for (const w of walls) {
        if (bulletHitsRect(b, w)) {
          hitWall = true;
          break;
        }
      }


      if (hitWall) {
        bullets.splice(i, 1);
        continue;
      }

      // ---- LIFETIME ----
      b.life -= dt;
      if (b.life <= 0) {
        bullets.splice(i, 1);
      }
    }





    // Power-ups floor lifetime & pickup
    for (let i=powerDrops.length-1;i>=0;i--) {
      const p = powerDrops[i];
      if ((now - p.created) / 1000 >= p.ttl) { powerDrops.splice(i,1); continue; }
      const d = Math.hypot(player.x - p.x, player.y - p.y);
      if (d < 22) {
        pickupPower(p);
        powerDrops.splice(i,1);
      }
    }

    // Power-up effect timers
    if (activePowers.insta && now >= activePowers.timers.insta) activePowers.insta=false;
    if (activePowers.double && now >= activePowers.timers.double) activePowers.double=false;
    if (activePowers.death && now >= activePowers.timers.death) {
      activePowers.death=false;
      if (player.prevGunBeforeDeath) player.currentGun = player.prevGunBeforeDeath;
      player.prevGunBeforeDeath = null;
    }

    // Update UI
    uiRound.textContent = round;
    uiZombiesLeft.textContent = aliveCount
      ? `${player.currentGun.name} [UPG ${player.currentGun.upgradeLevel}]`
      : 'None';


    const powersActive = [];
    if (activePowers.insta) powersActive.push('Insta-Kill');
    if (activePowers.double) powersActive.push('2x Points');
    if (activePowers.death) powersActive.push('Death Machine');
    const perksActive = Object.entries(player.perks)
      .filter(([k,v])=>v && k!=='quickReviveUsed')
      .map(([k])=>(k==='quickReviveUsed')?'':k)
      .map(k => ({
        juggernog:'Juggernog',
        speedCola:'Speed Cola',
        doubleTap:'Double Tap',
        staminUp:'Stamin-Up',
        quickRevive:'Quick Revive'
      }[k]))
      .filter(Boolean);

    
  }


  function screenToWorld(x, y) {
    return {
      x: x / camera.zoom + camera.x,
      y: y / camera.zoom + camera.y
    };
  }


  function getMouseWorldPos() {
    return {
      x: mouse.x / camera.zoom + camera.x,
      y: mouse.y / camera.zoom + camera.y
    };
  }



  

// ================================
// üéµ BACKGROUND MUSIC MANAGER
// ================================
const MusicPlayer = {
  playlist: [
    'assets/music/song1.mp3',
    'assets/music/song2.mp3',
    'assets/music/song3.mp3',
    'assets/music/song4.mp3',
    'assets/music/song5.mp3',
    'assets/music/song6.mp3',
    'assets/music/song7.mp3',
    'assets/music/song8.mp3',
    'assets/music/song9.mp3',
    'assets/music/song10.mp3',
    'assets/music/song11.mp3',
    'assets/music/song12.mp3',
    'assets/music/song13.mp3',
  ],

  audio: new Audio(),
  currentIndex: 0,
  shuffle: true,
  playedIndices: [],

  init() {
    // register this as the active music source
    window.currentMusic = this.audio;

    this.audio.loop = false;
    this.applyVolume();

    this.audio.addEventListener('ended', () => this.playNext());
  },

  applyVolume() {
    const music = window.musicVolume ?? 0.6;
    const master = window.MASTER_VOLUME ?? 1;

    this.audio.volume = music * master;
  },

  setVolume(v) {
    window.musicVolume = Math.max(0, Math.min(1, v));
    this.applyVolume();
  },

  play() {
    if (!this.audio.src) {
      this.pickNextIndex();
      this.audio.src = this.playlist[this.currentIndex];
    }

    this.applyVolume();
    this.audio.play();
  },

  pause() {
    this.audio.pause();
  },

  stop() {
    this.audio.pause();
    this.audio.currentTime = 0;
  },

  toggleShuffle() {
    this.shuffle = !this.shuffle;
    console.log('Shuffle:', this.shuffle ? 'ON' : 'OFF');
  },

  pickNextIndex() {
    if (this.shuffle) {
      if (this.playedIndices.length >= this.playlist.length) {
        this.playedIndices = [];
      }

      let next;
      do {
        next = Math.floor(Math.random() * this.playlist.length);
      } while (this.playedIndices.includes(next));

      this.playedIndices.push(next);
      this.currentIndex = next;
    } else {
      this.currentIndex = (this.currentIndex + 1) % this.playlist.length;
    }
  },

  playNext() {
    this.pickNextIndex();
    this.audio.src = this.playlist[this.currentIndex];
    this.applyVolume();
    this.audio.play();
  }
};

// Initialize once
MusicPlayer.init();


  function drawGrenades() {
  ctx.save();

  for (const g of grenades) {
    const now = performance.now();

    // Grenade color (flash near explosion)
    let bodyColor = '#2ecc71';

    if (g.armed) {
      const fuse =
        g.type === "monkey"
          ? MONKEY_EXPLODE_TIME
          : GRENADE_FUSE_TIME;

      const t = (g.explodeAt - now) / fuse;
      if (t < 0.3) bodyColor = '#ff3b3b';
    }

    // üß® Grenade body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(g.x, g.y, 5, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}






  function draw() {
    // ‚úÖ ALWAYS start clean
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updateCamera();

    // ‚úÖ APPLY CAMERA ONCE
    ctx.save();

    // Apply camera transform
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);
    
    for (const d of doors) {
      if (d.open) continue;

      ctx.save();
      ctx.translate(d.x, d.y);
      ctx.rotate((d.rotation || 0) * Math.PI / 180);
      ctx.fillStyle = '#7b5';
      ctx.fillRect(-d.w/2, -d.h/2, d.w, d.h);
      ctx.restore();
    }



    // Map background
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    if (SHOW_WORLD_BORDER) {
      drawWorldBorder();
    }



    for (const t of zombieTraps) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.rotate((t.rotation || 0) * Math.PI / 180);

      ctx.fillStyle = t.active ? '#ff0000' : '#550000';
      ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);

      if (t.active) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(-t.w / 2, -t.h / 2, t.w, t.h);
      }

      ctx.restore();
    }



   // =====================
// Draw walls (center-based, rotated)
// =====================
for (const w of walls) {
  ctx.save();
  ctx.translate(w.x, w.y);
  ctx.rotate((w.rotation || 0) * Math.PI / 180);

  ctx.fillStyle = '#555';

  if (w.slope) {
    // üî∫ slope wall (triangle)
    ctx.beginPath();

    const flipped = w.flip === true;

    if (w.slope === 'left') {
      if (!flipped) {
        // normal left slope
        ctx.moveTo(-w.w / 2,  w.h / 2);
        ctx.lineTo( w.w / 2,  w.h / 2);
        ctx.lineTo(-w.w / 2, -w.h / 2);
      } else {
        // flipped left slope (upside down)
        ctx.moveTo(-w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2, -w.h / 2);
        ctx.lineTo(-w.w / 2,  w.h / 2);
      }
    }

    else if (w.slope === 'right') {
      if (!flipped) {
        // normal right slope
        ctx.moveTo(-w.w / 2,  w.h / 2);
        ctx.lineTo( w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2,  w.h / 2);
      } else {
        // flipped right slope (upside down)
        ctx.moveTo(-w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2,  w.h / 2);
      }
    }

    ctx.closePath();
    ctx.fill();
  } else {
    // üß± normal wall
    ctx.fillRect(-w.w / 2, -w.h / 2, w.w, w.h);
  }

  ctx.restore();
}




    // =====================
    // Draw barriers (top-left based, rotated)
    // =====================
    for (const b of barriers) {
      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;
      const rot = (b.rotation || 0) * Math.PI / 180;
      const hpPct = b.hp / b.hpMax;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rot);

      // base
      ctx.fillStyle = '#333';
      ctx.fillRect(-b.w / 2, -b.h / 2, b.w, b.h);

      // HP fill (fills from top ‚Üí bottom)
      ctx.fillStyle = b.open ? '#a33' : '#3a7';
      ctx.fillRect(
       -b.w / 2,
       -b.h / 2,
       b.w,
       b.h * hpPct
      );

      // outline
      ctx.strokeStyle = '#555';
      ctx.strokeRect(-b.w / 2, -b.h / 2, b.w, b.h);

      ctx.restore();
    }

    for (const w of walls) {
      if (rectIntersect(player, w)) {
        player.x = player.prevX;
        player.y = player.prevY;
      }
    }

    // Interactables (dynamic labels for wall-buys showing ammo price)
    for (const i of interacts) {

      // ‚≠ê MYSTERY BOX COLOR LOGIC
      if (i.type === 'box') {
        const box = i.ref; // reference to mysteryBoxes entry

        ctx.fillStyle = box && box.active
          ? '#ffcc00'   // ACTIVE mystery box
          : '#555555';  // INACTIVE mystery box
      }
      else {
        ctx.fillStyle =
          i.type === 'upgrade' ? '#c77dff' :
          i.type === 'perk'
            ? (perkColors[i.perk] || '#264653')
            : i.type === 'wall'
              ? '#2a9d8f'
              : '#aaa';
      }


      ctx.beginPath();
      ctx.arc(i.x, i.y, 12, 0, TWO_PI);
      ctx.fill();



      ctx.fillStyle = '#ddd';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      let label = '';

      if (i.type === 'box') {
        const box = i.ref;
        label = box && box.active
          ? `Mystery Box (${i.cost})`
          : 'Inactive Mystery Box';
      }
      else {
        label = typeof i.label === 'function' ? i.label() : i.label;
      }

      if (i.type === 'wall') {
        const gunName = i.gunName; // ‚Üê map-based wall buys use gunName
        const owned = !!player.guns[gunName];
        const ammoCost = Math.floor(i.cost / 2);
        label = owned
          ? `Ammo for ${gunName} (${ammoCost})`
          : i.label;
      }
      ctx.fillText(label, i.x, i.y - 20);
      const d = Math.hypot(player.x - i.x, player.y - i.y);
      if (d < 60) {
        if (i.type !== 'box' || (i.ref && i.ref.active)) {
          ctx.fillStyle = '#bbb';
          ctx.fillText('Press E', i.x, i.y + 24);
        }
      }

    }

    doors.forEach(d => {
      if (d.open) return; // üö™ opened doors vanish

      ctx.save();
      ctx.translate(d.x, d.y);
      ctx.rotate((d.rotation || 0) * Math.PI / 180);

      ctx.fillStyle = '#7b5';
      ctx.fillRect(-d.w / 2, -d.h / 2, d.w, d.h);

      ctx.restore();
    });


    // Power-ups on floor
    for (const p of powerDrops) {
      ctx.fillStyle = powerColors[p.type];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, TWO_PI);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(p.type, p.x, p.y - 16);
    }

    // Bullets
    ctx.fillStyle = '#f5f5f5';
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, 2, 0, TWO_PI);
      ctx.fill();
    }

    drawGrenades();
    drawGrenadeExplosions();
    // Zombies
    for (const z of zombies) {
      if (!z.alive) continue;
      ctx.fillStyle = '#8b0000';
      ctx.beginPath();
      ctx.arc(z.x, z.y, z.r, 0, TWO_PI);
      ctx.fill();
      ctx.fillStyle = '#222';
      ctx.fillRect(z.x-12, z.y-18, 24, 4);
      const pct = clamp(z.hp / z.hpMax, 0,1);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(z.x-12, z.y-18, 24*pct, 4);

      // Boss zombies are purple, regular are red
      ctx.fillStyle = z.isBoss ? '#8b008b' : '#8b0000';
      ctx.beginPath();
      ctx.arc(z.x, z.y, z.r, 0, TWO_PI);
      ctx.fill();
  
      // Boss glow effect
      if (z.isBoss) {
        ctx.strokeStyle = '#ff00ff';
        ctx.lineWidth = 3;
        ctx.stroke();
    }}

    // Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.fillStyle = '#4c8bf5';
    ctx.beginPath();
    ctx.arc(0,0,14,0,TWO_PI);
    ctx.fill();
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(20,0);
    ctx.stroke();
    ctx.restore();

    // Game over overlay
    if (!player.alive) {
      /* PERK WIPE */
      player.perks = { juggernog:false, speedCola:false, doubleTap:false, staminUp:false, quickRevive:false, quickReviveUsed:false };
      player.quickRevive.level = 0;
      player.quickRevive.cost = player.quickRevive.baseCost;
    }

if (player.downed) {
  ctx.save();

  // ‚úÖ FORCE SCREEN SPACE (ignore camera)
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const cw = canvas.width;
  const ch = canvas.height;
  const cx = cw / 2;
  const cy = ch / 2;

  // ---------- Dark overlay ----------
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, cw, ch);

  // ---------- Center box ----------
  const boxW = 380;
  const boxH = 200;
  const bx = cx - boxW / 2;
  const by = cy - boxH / 2;

  ctx.fillStyle = '#111';
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 3;
  ctx.fillRect(bx, by, boxW, boxH);
  ctx.strokeRect(bx, by, boxW, boxH);

  // ---------- Text ----------
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Title
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 42px system-ui';
  ctx.fillText('REVIVING', cx, by + 50);

  // ---------- Timer number ----------
  const timeLeft = Math.max(0, player.reviveTimer);
  ctx.fillStyle = '#ffffff';
  ctx.font = '28px system-ui';
  ctx.fillText(
    timeLeft.toFixed(1),
    cx,
    by + 105
  );

  // ---------- Progress bar ----------
  const barW = 280;
  const barH = 18;
  const barX = cx - barW / 2;
  const barY = by + 140;

  const progress = clamp(
    timeLeft / player.reviveDuration,
    0,
    1
  );

  // Bar background
  ctx.fillStyle = '#333';
  ctx.fillRect(barX, barY, barW, barH);

  // Bar fill
  ctx.fillStyle = '#1abc9c';
  ctx.fillRect(barX, barY, barW * progress, barH);

  // Bar outline
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 2;
  ctx.strokeRect(barX, barY, barW, barH);

  ctx.restore();
}
const healthPct = Math.max(
    0,
    Math.min(1, player.hitsRemaining / player.hitsMax)
  );



///--------------------
    // Round transition banner (TOP, no dimming)

    ctx.restore(); // end camera

    // UI overlays (round banner, game over, revive)
    drawRoundBanner();
    drawLowHealthVignette(ctx, healthPct);
    drawWeaponHUD();
    drawPointsHUD();
    drawPerkIcons();
    drawPowerUpIcons();
    updateZombieUI();

  }

  function loop(t) {
    now = t;
    const dt = (t - lastTime) / 1000;
    lastTime = t;

    if (!gamePaused && (player.alive || player.downed)) {
      update(dt);
    }


    draw();

    if (gamePaused) {
      drawPauseOverlay();
    }

    requestAnimationFrame(loop);
  }

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    requestAnimationFrame(loop);
  
})();
</script>
</body>
</html>
