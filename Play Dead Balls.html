
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DEAD BALLS</title>
<style>
  html, body { margin:0; padding:0; background:#111; color:#eee; font-family:system-ui, sans-serif; }
  #ui { position:fixed; left:10px; top:10px; z-index:10; }
  .row { margin-bottom:6px; }
  #game { display:block; margin:12px auto; border:2px solid #444; background:#1a1a1a; }
  .help-panel {
    padding:8px;
    margin-top:8px;
    font-size:12px;
    max-width:260px;
  }

  .help-panel ul {
    padding-left:16px;
    margin:4px 0 0 0;
  }

  .help-panel hr {
    border-color:#444;
    margin:6px 0;
  }

  .badge { display:inline-block; padding:2px 6px; margin-right:6px; border:1px solid #666; border-radius:4px; }
  .power { margin-top:4px; font-size:12px; color:#ddd; }
  #menu {
    position:fixed;
    inset:0;
    background:#111;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:999;
    }

  #menu h1 {
    margin-bottom:20px;
  }

  #menu button {
    padding:10px 20px;
    font-size:18px;
    cursor:pointer;
  }

  .round-ui {
    font-size: 14px;
    letter-spacing: 2px;
    color: #aaa;
  }

  .round-number {
   display: inline-block;
    margin-left: 6px;
    font-size: 42px;          /* üî• BIG */
    font-weight: 900;
    color: #e74c3c;           /* üî¥ RED */
    text-shadow:
      0 0 6px rgba(231, 76, 60, 0.8),
      0 0 12px rgba(0, 0, 0, 0.8);
  }

  /* Zombie counter (matches ROUND style but no big number) */
  .zombie-ui {
    margin-top: 4px;
   font-size: 14px;
    letter-spacing: 2px;
    color: #aaa;
  }

  .zombie-number {
    display: inline-block;
    margin-left: 6px;
    font-size: 14px;      /* same size as text */
    font-weight: 700;
    color: #f1c40f;       /* yellow for visibility */
  }




</style>
</head>
<body>
<div id="ui">
  <div class="row round-ui">
    ROUND
    <span id="round" class="round-number">1</span>
  </div>

  <div class="row round-ui zombie-ui">
    ZOMBIES LEFT
    <span id="zombiesLeft" class="zombie-number">0</span>
  </div>



  <div id="gameOver" style="
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.85);
    display:none;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:1000;
    color:white;
    text-align:center;
  ">
    <h1 style="font-size:64px;margin-bottom:20px;">GAME OVER</h1>

    <div>F5 - Back to Main Menu / Reload game</div>

    <button id="restartBtn" style="
      padding:14px 28px;
      font-size:22px;
      cursor:pointer;
    ">
      Restart Game
    </button>
  </div>


</div>
<div id="menu">
  <h1>üßü DEAD BALLS</h1>

  <input type="file" id="mapLoader" accept=".json">
  <br><br>

  <button id="startBtn" disabled>Start Game</button>

  <p id="mapName">No map loaded</p>
</div>

<canvas id="game"></canvas>






<script src="scripts/guns.js"></script>
<script src="scripts/gun_sounds.js"></script>
<script src="scripts/powerup_sounds.js"></script>



<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvasToScreen() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    camera.w = canvas.width;
    camera.h = canvas.height;
  }



  // resize once on load
  function resizeCanvasToScreen() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }


  // resize when browser window changes
  window.addEventListener('resize', resizeCanvasToScreen);


  // UI elements
  const uiRound = document.getElementById('round');
  const uiPoints = document.getElementById('points');
  const uiHealth = document.getElementById('health');
  const uiHealthMax = document.getElementById('healthMax');
  const uiWeapon = document.getElementById('weapon');
  const uiAmmo = document.getElementById('ammo');
  const uiPowers = document.getElementById('powers');
  const uiPerks = document.getElementById('perks');
  const uiZombiesLeft = document.getElementById('zombiesLeft');
  
  
  const restartBtn = document.getElementById('restartBtn');

  if (restartBtn) {
    restartBtn.onclick = () => {
      restartGame();
    };
  }





  let LOADED_MAP = null;
  let gameStarted = false;
  let WIDTH = canvas.width;
  let HEIGHT = canvas.height;
  let WORLD_WIDTH = WIDTH;
  let WORLD_HEIGHT = HEIGHT;
  let gamePaused = false;
  let musicVolume = 0.5;
  window._musicTracks = [];


  // ONLY set defaults if no map is loaded
    if (!LOADED_MAP) {
      WORLD_WIDTH = WIDTH;
      WORLD_HEIGHT = HEIGHT;
    }


  let roundBannerStart = 0;
  const ROUND_BANNER_DURATION = 2000; // ms

  
  

  const menu = document.getElementById('menu');
  const mapLoader = document.getElementById('mapLoader');
  const startBtn = document.getElementById('startBtn');
  const mapNameText = document.getElementById('mapName');

  mapLoader.addEventListener('change', () => {
    const file = mapLoader.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      try {
        LOADED_MAP = JSON.parse(reader.result);
        mapNameText.textContent = `Loaded: ${file.name}`;
        startBtn.disabled = false;
      } catch {
        alert("Invalid map file");
      }
    };
    reader.readAsText(file);
  });

  startBtn.onclick = () => {
    zombies.length = 0;
    bullets.length = 0;
    loadMap(LOADED_MAP);
    menu.style.display = 'none';

    gameStarted = true;
    round = 1;
    startRoundSpawns();
    MusicPlayer.play();
  };



  function drawWorldBorder() {
    ctx.save();

    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 4 / camera.zoom; // consistent thickness
    ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    ctx.restore();
  }





  // ===== GLOBAL GAME ARRAYS (MUST BE ABOVE loadMap) =====
  const zombies = [];
  const bullets = [];
  const barriers = [];
  const zombieSpawns = [];
  const walls = [];
  const mysteryBoxes = [];
  const perkMachines = [];
  const upgradeStations = [];
  const wallBuys = [];
  const interacts = [];
  const powerDrops = [];
  const SHOW_WORLD_BORDER = true;
  const doors = [];
  const ZOMBIE_STUCK_TIME = 10.5;     // seconds before considered stuck
  const ZOMBIE_STUCK_DIST = 2;      // px movement threshold
  const ZOMBIE_TELEPORT_RADIUS = 15 * 15; // 25 blocks √ó 20px grid
  // ===== MYSTERY BOX SYSTEM =====
  let activeMysteryIndex = -1;
  let mysterySpinCount = 0;
  window.MASTER_VOLUME = window.MASTER_VOLUME ?? 0.6;
  window.musicVolume = window.musicVolume ?? 0.6;
  window.powerupVolume = 0.6;

  const MYSTERY_MOVE_SPINS = 10;
  const MYSTERY_MOVE_CHANCE = 0.45;
  const zombieTraps = [];
  const musicSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};

const masterSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};
const powerupSlider = {
  x: 0, y: 0,
  width: 180,
  height: 6,
  knobRadius: 8,
  dragging: false
};

  

  const PLAYER_DEFAULTS = {
    speed: 140,
    hitsMax: 3,
   reviveDuration: 5
  };


  // ===== POWER-UP ICONS =====
  const powerIcons = {
    insta: new Image(),
    double: new Image(),
    nuke: new Image(),
    max: new Image(),
    carpenter: new Image(),
    death: new Image()
  };

  // üîÅ replace paths with your custom PNGs
  powerIcons.insta.src = 'assets/powerups/insta.png';
  powerIcons.double.src = 'assets/powerups/2x.png';
  powerIcons.nuke.src = 'assets/powerups/nuke.png';
  powerIcons.max.src = 'assets/powerups/max.png';
  powerIcons.carpenter.src = 'assets/powerups/carpenter.png';
  powerIcons.death.src = 'assets/powerups/death.png';


  // ===== PERK ICONS =====
  const perkIcons = {
    juggernog: new Image(),
    speedCola: new Image(),
    doubleTap: new Image(),
    staminUp: new Image(),
    quickRevive: new Image()
  };

  perkIcons.juggernog.src = 'assets/perks/juggernog.png';
  perkIcons.speedCola.src = 'assets/perks/speedCola.png';
  perkIcons.doubleTap.src = 'assets/perks/doubleTap.png';
  perkIcons.staminUp.src = 'assets/perks/staminUp.png';
  perkIcons.quickRevive.src = 'assets/perks/quickRevive.png';


  const perkColors = {
    juggernog:  '#e74c3c', 
    speedCola:  '#3498db', 
    doubleTap:  '#f1c40f', 
    staminUp:   '#f57242', 
    quickRevive:'#1abc9c'  
  };


  // ===== ZOMBIE DROP RARITIES =====
  const DROP_RARITIES = {
    common: {
      chance: 0.35,
      drops: ['2X', 'CARPENTER']
    },
    rare: {
      chance: 0.15,
      drops: ['INSTA', 'MAX']
    },
    legendary: {
      chance: 0.05,
      drops: ['NUKE', 'DEATH']
    }
  };


window.setMasterVolume = v => {
  MASTER_VOLUME = Math.max(0, Math.min(1, v));
};

window.setMusicVolume = v => {
  window.musicVolume = Math.max(0, Math.min(1, v));

  // apply to ALL registered music
  for (const track of window._musicTracks) {
    if (!track) continue;
    track.volume = window.musicVolume;
  }
};

// ===== ACTIVE MUSIC TRACK =====
window.currentMusic = null;

window.musicVolume = window.musicVolume ?? 0.6;

window.setMusicVolume = function (v) {
  window.musicVolume = Math.max(0, Math.min(1, v));

  // APPLY IMMEDIATELY
  if (window.currentMusic) {
    window.currentMusic.volume =
      window.musicVolume * (window.MASTER_VOLUME ?? 1);
  }
};

  

  // ===== CAMERA =====
  const camera = {
      x: 0,
      y: 0,
      zoom: 1.3,
      w: window.innerWidth,
      h: window.innerHeight
    };

    // ‚úÖ FIRST SAFE CALL
    resizeCanvasToScreen();
    camera.w = canvas.width;
    camera.h = canvas.height;

    // ‚úÖ SAFE resize listener
    window.addEventListener('resize', () => {
      resizeCanvasToScreen();
      camera.w = canvas.width;
      camera.h = canvas.height;
    })

    resizeCanvasToScreen();



    function clampPlayerToWorld() {
      player.x = clamp(player.x, player.radius, WORLD_WIDTH - player.radius);
      player.y = clamp(player.y, player.radius, WORLD_HEIGHT - player.radius);
    }

    function isSpawnUnlocked(spawn) {
      // No door link = always active
      if (!spawn.linkedDoorId) return true;

      const door = doors.find(d => d.id === spawn.linkedDoorId);
      if (!door) return true; // safety fallback

      return door.open === true;
    }


  

  window.loadMap = function(map) {
    console.log("LOADING MAP", map);
    



  // Map size
    if (map.width && map.height) {
        WORLD_WIDTH = map.width;
        WORLD_HEIGHT = map.height;
      }


    doors.length = 0;

    if (Array.isArray(map.doors)) {
      map.doors.forEach(d => {
        doors.push({
          id: d.id,
          x: d.x,
          y: d.y,
          w: d.w,
          h: d.h,
          rotation: d.rotation || 0,
          cost: d.cost,
          open: false
        });

      });
    }




  // Reset barriers AFTER creation
    for (const b of barriers) {
      b.hpMax = b.hpMax ?? 100;
      b.hp = b.hpMax;
      b.open = false;
    }


  // Clear existing data
    barriers.length = 0;
    perkMachines.length = 0;
    wallBuys.length = 0;
    mysteryBoxes.length = 0;
    upgradeStations.length = 0;
    zombieSpawns.length = 0;
    interacts.length = 0;
    zombieTraps.length = 0;

    if (map.spawns && map.spawns.length > 0) {
      player.x = map.spawns[0].x;
      player.y = map.spawns[0].y;
    }

    



    /* ---------- WALLS (CENTER ‚Üí TOP-LEFT FIX) ---------- */
    /* ---------- WALLS (CENTER-BASED) ---------- */
    walls.length = 0;

    if (Array.isArray(map.walls)) {
      map.walls.forEach(w => {
        walls.push({
          x: w.x,
          y: w.y,
          w: w.w,
          h: w.h,
          rotation: w.rotation || 0,
          slope: w.slope || null,
          flip: w.flip === true  
        });
      });
    }
      doors.forEach(d => {
        if (!d.open) {
          resolveCircleWallCollision(player, d);
          zombies.forEach(z => resolveCircleWallCollision(z, d));
        }
      });

    // ---------- TRAP INTERACTS ----------
    // ---------- ZOMBIE TRAP INTERACTS ----------








  /* ---------- BARRIERS ---------- */
  /* ---------- BARRIERS ---------- */
  /* ---------- BARRIERS (CENTER ‚Üí TOP-LEFT FIX) ---------- */
    if (Array.isArray(map.barriers)) {
      map.barriers.forEach(b => {
        barriers.push({
          // convert center-based to top-left
          x: b.x - b.w / 2,
          y: b.y - b.h / 2,
          w: b.w,
          h: b.h,

          rotation: b.rotation || 0, // keep for future
          hpMax: 100,
          hp: 100,
          open: false
        });
      });
    }



    

    // ---------- PLAYER SPAWN ----------
    if (Array.isArray(map.playerSpawns) && map.playerSpawns.length > 0) {
      const s = map.playerSpawns[Math.floor(Math.random() * map.playerSpawns.length)];
      player.x = s.x;
      player.y = s.y;
    } else {
      // fallback
      player.x = WORLD_WIDTH / 2;
      player.y = WORLD_HEIGHT / 2;
    }

  /* ---------- INTERACTABLES ---------- */
    if (Array.isArray(map.interacts)) {
      map.interacts.forEach(obj => {




        if (obj.type === 'perk') {
          perkMachines.push({
            x: obj.x,
            y: obj.y,
            perk: obj.perk,
            cost: obj.cost
          });
        }

        else if (obj.type === 'wallbuy') {
          wallBuys.push({
            x: obj.x,
            y: obj.y,
            gun: obj.gun,
            cost: obj.cost
          });
        }

        else if (obj.type === 'mystery') {
          mysteryBoxes.push({
            x: obj.x,
            y: obj.y,
            cost: obj.cost
          });
        }

        else if (obj.type === 'upgrade') {
          upgradeStations.push({
            x: obj.x,
            y: obj.y,
            cost: obj.cost
          });
        }

        else if (obj.type === 'trap') {
          zombieTraps.push({
            x: obj.x,
            y: obj.y,
            w: obj.w,
            h: obj.h,
            cost: obj.cost,
            duration: obj.duration ?? 10,
            cooldown: obj.cooldown ?? 10,

            // üî• RUNTIME STATE (MUST LIVE HERE)
            active: false,
            pending: false,
            activateAt: 0,
            activeUntil: 0,
            cooldownUntil: 0
          });

        }


        else {
          console.warn("Unknown interact type:", obj);
        }
      });
    }

    //------------------
    // Rebuild interact list (used by draw() and E key)
    for (const p of perkMachines) {
      interacts.push({
        type: 'perk',
        x: p.x,
        y: p.y,
        perk: p.perk,
        cost: p.cost,
        label: () => `${p.perk} (${p.cost})`,
        action: () => tryBuyPerk(p.perk, p.cost)


      });
    }


  for (const w of wallBuys) {
    interacts.push({
      type: 'wall',
      x: w.x,
      y: w.y,
      gunName: w.gun,
      cost: w.cost,
      label: `Buy ${w.gun} (${w.cost})`,
      action: () => {
        const gunKey = w.gun.trim().toUpperCase();
        const gun = WALL_BUY_GUNS[gunKey];

        if (!gun) {
          console.warn("Invalid wall-buy gun:", w.gun);
          return;
        }

        tryBuyAmmoOrGun(gun, w.cost);
      }


    });
  }

  for (const m of mysteryBoxes) {
    interacts.push({
      type: 'box',
      x: m.x,
      y: m.y,
      cost: m.cost,
      label: () =>
        m.active
          ? `Mystery Box (${m.cost})`
          : `Inactive Mystery Box`,
      action: () => {
        if (!m.active) return;
        tryMysteryBox(m.cost);
      },
      ref: m // üîë keep reference
    });
  }


  for (const d of doors) {
    interacts.push({
      type: 'door',
      x: d.x,
      y: d.y,
      cost: d.cost,
      label: `Open Door (${d.cost})`,
      action: () => tryBuyDoor(d)
    });
  }


  for (const u of upgradeStations) {
    interacts.push({
      type: 'upgrade',
      x: u.x,
      y: u.y,
      r: 48, // ‚úÖ REQUIRED for E key detection
      cost: u.cost,
      label: () => {
        const g = player.currentGun;
        if (!g) return 'Upgrade Weapon';
        return `Upgrade ${g.name} (${u.cost})`;
      },
      action: () => tryUpgradeCurrentGun(u.cost)
    });
  }


    // ---------- ZOMBIE TRAP INTERACTS ----------
    // ---------- ZOMBIE TRAP INTERACTS ----------
    for (const t of zombieTraps) {

      // ‚úÖ SAFETY INIT (VERY IMPORTANT)
      if (t.cooldownUntil == null) t.cooldownUntil = 0;
      if (t.activeUntil == null) t.activeUntil = 0;
      if (t.activateAt == null) t.activateAt = 0;
      if (t.pending == null) t.pending = false;
      if (t.active == null) t.active = false;

      interacts.push({
        x: t.x,
        y: t.y,
        r: 48,

        label() {
          const now = performance.now();

          if (t.active) return 'Trap Active';
          if (t.pending) return 'Activating...';
          if (now < t.cooldownUntil) return 'Cooling Down...';

          return `Activate Trap (${t.cost})`;
        },

        action() {
          const now = performance.now();

            if (t.active) return;
            if (t.pending) return;
            if (now < t.cooldownUntil) return;
            if (player.points < t.cost) return;

            player.points -= t.cost;

            t.pending = true;
            t.activateAt = now + 2000;
          }

      });
    }




  function initMysteryBoxes() {
    if (mysteryBoxes.length === 0) return;

    activeMysteryIndex = Math.floor(Math.random() * mysteryBoxes.length);

    mysteryBoxes.forEach((b, i) => {
      b.active = i === activeMysteryIndex;
    });
  }

  initMysteryBoxes();



    

  /* ---------- ZOMBIE SPAWNS ---------- */
    if (Array.isArray(map.spawns)) {
      map.spawns.forEach(s => {
        zombieSpawns.push({
          x: s.x,
          y: s.y,
          linkedDoorId: s.linkedDoorId ?? null
        });
      });
    }

    console.log("MAP APPLIED");
  };


  function gameOver() {
    const go = document.getElementById('gameOver');
    if (go) go.style.display = 'flex';
  }


  function zombieBlockedByBarrier(z) {
    const b = z.targetBarrier;
    if (!b) return false;

    // barrier exists and is NOT open / broken
    return !b.open;
  }



  function ownedGunCount() {
    return Object.keys(player.guns).length;
  }

  function removeCurrentGunIfNeeded() {
    const gunNames = Object.keys(player.guns);

    // Nothing to remove
    if (gunNames.length <= 1) return;

    // If holding pistol AND have another gun ‚Üí remove pistol
    if (
      player.currentGun.name === 'Pistol' &&
      gunNames.length >= MAX_GUNS
    ) {
      delete player.guns['Pistol'];

      // Switch to any remaining gun
      const next = Object.keys(player.guns)[0];
      player.currentGun = player.guns[next];
      return;
    }

    // Otherwise remove the currently held gun
    delete player.guns[player.currentGun.name];

    // Fallback to pistol or first available gun
    player.currentGun =
      player.guns['Pistol'] ??
      player.guns[Object.keys(player.guns)[0]];
  }



  function handleZombieStuck(z, dt) {
    const dx = z.x - z.lastX;
    const dy = z.y - z.lastY;
    const moved = Math.hypot(dx, dy);

    if (moved < ZOMBIE_STUCK_DIST) {
      z.stuckTime += dt;
    } else {
      z.stuckTime = 0;
      z.lastX = z.x;
      z.lastY = z.y;
    }

    if (z.stuckTime >= ZOMBIE_STUCK_TIME) {
      const b = z.targetBarrier;
      if (b && !b.open) {
        return;
      }
      teleportZombieNearPlayer(z);
      z.stuckTime = 0;
      z.lastX = z.x;
      z.lastY = z.y;
    }

    }


    function updateZombieCounter() {
      uiZombiesLeft.textContent = zombies.filter(z => z.alive !== false).length;
      }



  function teleportZombieNearPlayer(z) {
    const radius = 15 * 15; // keep your value

    const angle = Math.random() * Math.PI * 2;
    const dist = Math.sqrt(Math.random()) * radius;

    const nx = player.x + Math.cos(angle) * dist;
    const ny = player.y + Math.sin(angle) * dist;

    z.x = clamp(nx, 20, WORLD_WIDTH - 20);
    z.y = clamp(ny, 20, WORLD_HEIGHT - 20);

    z.lastX = z.x;
    z.lastY = z.y;
    z.stuckTime = 0;
  }



  function circleRectHit(cx, cy, r, rx, ry, rw, rh) {
    const x = clamp(cx, rx, rx + rw);
    const y = clamp(cy, ry, ry + rh);
    const dx = cx - x;
    const dy = cy - y;
    return dx * dx + dy * dy <= r * r;
  }



  // Game constants
  function W() { return canvas.width; }
  function H() { return canvas.height; }
  const TWO_PI = Math.PI * 2;

  const rnd = (min, max) => Math.random() * (max - min) + min;
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const dist2 = (a,b) => { const dx = a.x - b.x, dy = a.y - b.y; return dx*dx + dy*dy; };

  const MAX_GUNS = 2;



  // Player
  const player = {
    x: WIDTH / 2,
    y: HEIGHT / 2,
    speed: 140,
    angle: 0,
    radius: 14,

    hitsMax: 3,
    hitsRemaining: 3,

    // ‚úÖ HEALTH REGEN
    lastHitTime: 0,        // timestamp of last damage
    regenDelay: 15000,      // ms after last hit before regen starts
    regenRate: 0.8,        // hits per second

    points: 420,
    currentGun: null,
    trapDamageImmunityUntil: 0,

    guns: {},
    downed: false,
    alive: true,
    reviveTimer: 0,
    reviveDuration: 5,
    zombieFearTimer: 0,

    perks: {
      juggernog:false,
      speedCola:false,
      doubleTap:false,
      staminUp:false,
      quickRevive:false,
      quickReviveUsed:false
    },

    repairing: { barrier:null, timer:0, ticks:0 }
  };


  // Weapons
  function makeGun(name, {damage, fireRate, mag, reserve, reload, speed, auto=true, cost=0}) {
  return {
    name,
    damage,
    fireRate,
    mag,
    magMax: mag,
    reserve,
    reserveMax: reserve,
    reload,
    bulletSpeed: speed,
    auto,
    cooldown: 0,
    reloading: false,
    reloadTimer: 0,
    cost,

    // ===== ADD THESE =====
    upgradeLevel: 0,
    baseDamage: damage,
    baseReserveMax: reserve,
    upgradeCost: 5000
  };
}




  const pistol = makeGun('Pistol', { damage: 20, fireRate: 4, mag: 10, reserve: 60, reload: 1.5, speed: 550, auto:false, cost:0 });
  const smg    = makeGun('SMG',    { damage: 28, fireRate: 10, mag: 30, reserve: 180, reload: 2.5, speed: 650, auto:true, cost:750 });
  const ar     = makeGun('AR',     { damage: 32, fireRate: 6, mag: 25, reserve: 150, reload: 3.0, speed: 700, auto:true, cost:900 });
  const shotgun = makeGun('SHOTGUN',{ damage: 50, fireRate: 1, mag: 8,  reserve: 48,  reload: 5.5, speed: 600, auto:false, cost:1000 });
  const m1sus = makeGun('M1 SUS',   { damage: 45, fireRate: 2, mag: 10,  reserve: 50,  reload: 3.0, speed: 750, auto:false, cost:1000 });
  const lmg    = makeGun('LMG',    { damage: 35, fireRate: 8, mag: 60, reserve: 240, reload: 4.5, speed: 700, auto:true, cost:0 });
  const sniper = makeGun('Sniper', { damage: 120, fireRate: 1.5, mag: 5, reserve: 30, reload: 2.2, speed: 1000, auto:false, cost:0 });

  const deathMachine = makeGun('Death Machine', { damage: 999, fireRate: 12, mag: Infinity, reserve: Infinity, reload: 0, speed: 800, auto:true, cost:0 });

  const WALL_BUY_GUNS = {
    PISTOL: pistol,
    SMG: smg,
    AR: ar,
    SHOTGUN: shotgun,
    SNIPER: sniper,
    // üî• NEW WALL BUY
    "M1 SUS": structuredClone(MYSTERY_BOX_GUNS.find(g => g.name === 'M1 SUS'))
  };

  // Power-ups
  const POWER_TYPES = ['INSTA', 'NUKE', '2X', 'MAX', 'CARPENTER', 'DEATH'];
  const powerColors = {
    'INSTA':'#e74c3c',
    'NUKE':'#f1c40f',
    '2X':'#9b59b6',
    'MAX':'#3498db',
    'CARPENTER':'#2ecc71',
    'DEATH':'#95a5a6'
  };

  const activePowers = {
    insta:false, double:false, death:false,
    timers: { insta:0, double:0, death:0 }
  };

  // Round / Zombie
  
  let aliveCount = 0;

  // Round cooldown state
  let round = 1;
  let roundCooldown = false;
  let roundCooldownEnd = 0;
  let showRoundBanner = false;
  let roundBannerText = '';


  // Spawn control (batch spawning)
  let spawnRemaining = 0;
  let spawnTimer = 0;

  // Map: barriers (rectangles) across corridors


  // ============================
// SLIDER HELPERS (GLOBAL)
// ============================

function updateSlider(slider, mx, setter) {
  const t = (mx - slider.x) / slider.width;
  setter(Math.max(0, Math.min(1, t)));
}

function hitSlider(slider, mx, my) {
  return (
    mx >= slider.x &&
    mx <= slider.x + slider.width &&
    my >= slider.y - slider.knobRadius &&
    my <= slider.y + slider.height + slider.knobRadius
  );
}



  function removeQuickReviveMachine() {

  for (let i = perkMachines.length - 1; i >= 0; i--) {
    if (perkMachines[i].perk === 'quickRevive') {
      perkMachines.splice(i, 1);
    }
  }

  for (let i = interacts.length - 1; i >= 0; i--) {
    if (interacts[i].type === 'perk' && interacts[i].perk === 'quickRevive') {
      interacts.splice(i, 1);
    }
  }

  // üö® FINAL LOCK
  player.quickReviveSoldOut = true;
}

  // ADD THIS HERE
  function rectCircleCollide(cx, cy, r, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) <= r * r;
  }



  function rollDropRarity(round) {
    let roll = Math.random();

    // Optional: better drops slightly more likely later rounds
    const roundBoost = Math.min(round * 0.005, 0.05);
    roll -= roundBoost;

    let acc = 0;
    for (const [rarity, data] of Object.entries(DROP_RARITIES)) {
      acc += data.chance;
      if (roll <= acc) return rarity;
    }
    return null;
  }


  // barrier object: {x,y,w,h,hp,hpMax,open:bool}
  function addBarrier(x,y,w,h) {
    barriers.push({x,y,w,h,hp:100, hpMax:100, open:false});
  }
  

  // Player init
  player.guns[pistol.name] = {...pistol};
  player.currentGun = player.guns[pistol.name];
  player.quickRevive = {
    buys: 0,
    maxBuys: 3
  };

  player.quickReviveSoldOut = false;

  function setPowerupVolume(t) {
  window.powerupVolume = Math.max(0, Math.min(1, t));
}


canvas.addEventListener('mousedown', e => {
  if (!gamePaused) return;

  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;
  const my = e.clientY - r.top;

  if (hitSlider(masterSlider, mx, my)) {
    masterSlider.dragging = true;
    updateSlider(masterSlider, mx, setMasterVolume);

  } else if (hitSlider(musicSlider, mx, my)) {
    musicSlider.dragging = true;
    updateSlider(musicSlider, mx, setMusicVolume);

  } else if (hitSlider(powerupSlider, mx, my)) {
    powerupSlider.dragging = true;
    updateSlider(powerupSlider, mx, setPowerupVolume);
  }
});

canvas.addEventListener('mousemove', e => {
  if (!gamePaused) return;

  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;

  if (masterSlider.dragging) {
    updateSlider(masterSlider, mx, setMasterVolume);
  }
  if (musicSlider.dragging) {
    updateSlider(musicSlider, mx, setMusicVolume);
  }
  if (powerupSlider.dragging) {
    updateSlider(powerupSlider, mx, setPowerupVolume);
  }
});

canvas.addEventListener('mouseup', () => {
  masterSlider.dragging = false;
  musicSlider.dragging = false;
  powerupSlider.dragging = false;
});






  // Input
    const keys = {};
    const mouse = { x: WIDTH/2, y: HEIGHT/2, down:false };


    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();

      if (e.key.toLowerCase() === 'r') {
        startReload(player.currentGun);
      }

      // ‚è∏ PAUSE TOGGLE (ESC)
      if (key === 'escape') {
        gamePaused = !gamePaused;



        // prevent stuck movement / shooting
        for (const k in keys) keys[k] = false;
        mouse.down = false;

        return;
      }

      // üî´ WEAPON SWAP
      if (key === '1') {
        swapGun();
        return;
      }

      keys[key] = true;
    });


    window.addEventListener('keyup', (e)=> { keys[e.key.toLowerCase()] = false; });
    canvas.addEventListener('mousemove', (e)=> {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', ()=> { mouse.down = true; });
    window.addEventListener('mouseup', ()=> { mouse.down = false; });

    function startRoundCooldown() {
      roundCooldown = true;
      roundCooldownEnd = now + 15000;

      showRoundBanner = true;
      roundBannerText = `ROUND ${round}`;
      roundBannerStart = performance.now();
    }
    
    function startReload(gun) {
      if (!gun) return;
      if (gun.reloading) return;
      if (gun.mag >= gun.magMax) return;
      if (gun.reserve <= 0) return;

      gun.reloading = true;
      playReloadSound(gun);

      const reloadMult = player.perks.speedCola ? 0.6 : 1;
      gun.reloadTimer = gun.reload * reloadMult;

    }



    function swapGun() {
      const gunNames = Object.keys(player.guns);

      // No swap if only one gun
      if (gunNames.length <= 1) return;

      const currentIndex = gunNames.indexOf(player.currentGun.name);
      const nextIndex = (currentIndex + 1) % gunNames.length;

      player.currentGun = player.guns[gunNames[nextIndex]];
    }


    function isInsideWall(x, y) {
    for (const w of walls) {
      const left   = w.x - w.w / 2;
      const right  = w.x + w.w / 2;
      const top    = w.y - w.h / 2;
      const bottom = w.y + w.h / 2;

      if (x > left && x < right && y > top && y < bottom) {
        return true;
      }
    }
    return false;
  }

  function clampToMap(x, y) {
    return {
      x: clamp(x, 20, WORLD_WIDTH - 20),
      y: clamp(y, 20, WORLD_HEIGHT - 20)
    };
  }


  function randomNearPlayer(radius = 50) {
    const angle = Math.random() * Math.PI * 2;
    const dist  = Math.random() * radius;
    return clampToMap(
      player.x + Math.cos(angle) * dist,
      player.y + Math.sin(angle) * dist
   );
  }

  

  function drawRoundBanner() {
    if (!showRoundBanner) return;

    const elapsed = performance.now() - roundBannerStart;
    if (elapsed > ROUND_BANNER_DURATION) {
      showRoundBanner = false;
      return;
    }

    const alpha = 1 - elapsed / ROUND_BANNER_DURATION;

    // üî• RESET TRANSFORM (THIS IS THE FIX)
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    ctx.globalAlpha = alpha;
    ctx.font = 'bold 56px system-ui';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.shadowColor = 'black';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 2;

    // ‚úÖ TRUE TOP-CENTER OF SCREEN
    ctx.fillText(
      roundBannerText,
      canvas.width / 2,
      80
    );

    ctx.restore();
  }



  function resolveCircleRotatedRectCollision(entity, rect) {
    const rot = (rect.rotation || 0) * Math.PI / 180;

  // Translate to rect space
    const dx = entity.x - rect.x;
    const dy = entity.y - rect.y;

    const cos = Math.cos(-rot);
    const sin = Math.sin(-rot);

    const lx = dx * cos - dy * sin;
    const ly = dx * sin + dy * cos;

    const hw = rect.w / 2;
    const hh = rect.h / 2;
    const r = entity.radius;

    // Find overlap in local space
    const overlapX = hw + r - Math.abs(lx);
    const overlapY = hh + r - Math.abs(ly);

    if (overlapX <= 0 || overlapY <= 0) return;

    let pushX = 0;
    let pushY = 0;

    // Resolve on smallest axis
    if (overlapX < overlapY) {
      pushX = lx > 0 ? overlapX : -overlapX;
    } else {
      pushY = ly > 0 ? overlapY : -overlapY;
    }

    // Rotate push vector back to world space
    const wx = pushX * cos + pushY * -sin;
    const wy = pushX * sin + pushY * cos;

    entity.x += wx;
    entity.y += wy;
  }



  function resolveCircleRotatedRectCollision(entity, rect){
    const rx = rect.x - rect.w / 2;
    const ry = rect.y - rect.h / 2;

    if (!rectCircleCollide(entity.x, entity.y, entity.radius, rx, ry, rect.w, rect.h)) {
      return;
    }

    // Push entity out on smallest axis
    const dx = entity.x - rect.x;
    const dy = entity.y - rect.y;

    const overlapX = rect.w / 2 + entity.radius - Math.abs(dx);
    const overlapY = rect.h / 2 + entity.radius - Math.abs(dy);

    if (overlapX < overlapY) {
      entity.x += dx > 0 ? overlapX : -overlapX;
    } else {
      entity.y += dy > 0 ? overlapY : -overlapY;
    }
  }


  function bulletHitsRect(b, r) {
    const cx = clamp(b.x, r.x, r.x + r.w);
    const cy = clamp(b.y, r.y, r.y + r.h);
    const dx = b.x - cx;
    const dy = b.y - cy;
    return (dx * dx + dy * dy) <= (b.radius * b.radius);
  }


    function barrierBetweenSpawnAndPlayer(spawnX, spawnY, barrier) {
  // Simple axis check (works for your corridor-style maps)
  const bx = barrier.x + barrier.w / 2;
  const by = barrier.y + barrier.h / 2;

  // If spawn and player are on opposite sides of the barrier
  const spawnSideX = spawnX < bx;
  const playerSideX = player.x < bx;

  const spawnSideY = spawnY < by;
  const playerSideY = player.y < by;

  return spawnSideX !== playerSideX || spawnSideY !== playerSideY;
}


  
  // ---------- NEW: Circle collision helpers ----------
  function resolveCircleCollision(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = (a.r || a.radius) + (b.r || b.radius);

    if (dist === 0 || dist >= minDist) return;

    const overlap = minDist - dist;
    const nx = dx / dist;
    const ny = dy / dist;

    // Push both apart evenly
    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;
  }
// --------------------------------------------------


// ===== EMPTY GUN SOUND =====
const emptyGunAudio = new Audio('assets/gun_sounds/empty_click.mp3');
emptyGunAudio.volume = 1;

let lastEmptySoundTime = 0;

function playEmptyGunSound() {
  const now = performance.now();

  // prevent spam (1 click every 200ms max)
  if (now - lastEmptySoundTime < 200) return;
  lastEmptySoundTime = now;

  const sfx = emptyGunAudio.cloneNode();
  sfx.volume = window.MASTER_VOLUME ?? 0.6;
  sfx.play();
}




  // Actions
  function tryBuyGun(gun, cost) {
    if (player.points >= cost) {
      player.points -= cost;
      if (!player.guns[gun.name]) player.guns[gun.name] = {...gun};
      player.currentGun = player.guns[gun.name];
    }
  }

  function tryBuyAmmoOrGun(gun, cost) {
    const owned = !!player.guns[gun.name];

  // ---------- BUY NEW GUN ----------
    if (!owned) {
      if (player.points < cost) return;

    // Enforce max guns
      if (ownedGunCount() >= MAX_GUNS) {
        removeCurrentGunIfNeeded();
      }

      player.points -= cost;
      player.guns[gun.name] = structuredClone(gun);
      player.currentGun = player.guns[gun.name];
      return;
    }

    // ---------- AMMO REFILL ----------
    const g = player.guns[gun.name];

    let ammoCost = Math.floor(cost / 2);

    // üî• Increase ammo cost if gun is upgraded
    if (g.upgradeLevel > 0) {
      ammoCost = Math.floor(ammoCost * 3.5);
    }

    if (player.points < ammoCost) return;

    player.points -= ammoCost;

    if (g.mag !== Infinity) {
      g.mag = g.magMax;
      g.reserve = g.reserveMax;
    }
  }


  function resetAllPerkEffects() {
  // ---- Reset perk flags ----
    for (const key in player.perks) {
      player.perks[key] = false;
    }

  // ---- Reset core stats ----
    player.speed = PLAYER_DEFAULTS.speed;

    player.hitsMax = PLAYER_DEFAULTS.hitsMax;
    player.hitsRemaining = player.hitsMax;

  // ---- Reset revive / fear logic ----
    player.reviveDuration = PLAYER_DEFAULTS.reviveDuration;
    player.zombieFearTimer = 0;

  // ---- Reset Quick Revive internal state ----
    player.quickRevive.level = 0;
    player.quickRevive.cost = player.quickRevive.baseCost;
    player.quickRevive.regenMultiplier = 1;

  // ---- Safety: clear any perk side-effects ----
    player.lastHitTime = performance.now();
  }


  function updateZombieUI() {
    if (!uiZombiesLeft) return;

    let count = 0;
    for (const z of zombies) {
      if (z.alive) count++;
    }

    uiZombiesLeft.textContent = count;
  }


  function drawRoundBanner() {
  if (!showRoundBanner) return;

  const elapsed = performance.now() - roundBannerStart;
  if (elapsed > ROUND_BANNER_DURATION) {
    showRoundBanner = false;
    return;
  }

  const alpha = 1 - elapsed / ROUND_BANNER_DURATION;

  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  ctx.globalAlpha = alpha;

  // üî¥ BIG RED ROUND NUMBER
  ctx.font = 'bold 96px system-ui';
  ctx.fillStyle = '#e74c3c';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  ctx.shadowColor = 'black';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetY = 4;

  ctx.fillText(
    round,
    canvas.width / 2,
    90
  );

  ctx.restore();
}


  function drawPowerUpIcons() {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const active = [];

  if (activePowers.insta) active.push('insta');
  if (activePowers.double) active.push('double');
  if (activePowers.death) active.push('death');

  if (active.length === 0) {
    ctx.restore();
    return;
  }

  const ICON_SIZE = 44;
  const SPACING = 12;

  const totalWidth =
    active.length * ICON_SIZE +
    (active.length - 1) * SPACING;

  const startX = canvas.width / 2 - totalWidth / 2;

  // ‚¨ÜÔ∏è POSITIONED ABOVE PERKS
  const y =
    canvas.height -
    (ICON_SIZE * 2) -
    28;

  active.forEach((key, i) => {
    const img = powerIcons[key];
    if (!img) return;

    const x = startX + i * (ICON_SIZE + SPACING);

    // background plate
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.roundRect(x - 4, y - 4, ICON_SIZE + 8, ICON_SIZE + 8, 8);
    ctx.fill();

    // clip icon (removes PNG black edges)
    ctx.save();
    ctx.beginPath();
    ctx.roundRect(x, y, ICON_SIZE, ICON_SIZE, 6);
    ctx.clip();

    ctx.drawImage(img, x, y, ICON_SIZE, ICON_SIZE);
    ctx.restore();
  });

  ctx.restore();
}


  function drawPerkIcons() {
  // IMPORTANT: reset camera so HUD is screen-fixed
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    const ownedPerks = Object.keys(player.perks)
      .filter(p => player.perks[p] && p !== 'quickReviveUsed');

    if (ownedPerks.length === 0) {
      ctx.restore();
      return;
    }

    const ICON_SIZE = 44;
    const SPACING = 12;

    const totalWidth =
      ownedPerks.length * ICON_SIZE +
      (ownedPerks.length - 1) * SPACING;

    const startX = canvas.width / 2 - totalWidth / 2;
    const y = canvas.height - ICON_SIZE - 16; // bottom middle

    ownedPerks.forEach((perk, i) => {
      const img = perkIcons[perk];
      if (!img) return;

      const x = startX + i * (ICON_SIZE + SPACING);

    // ===== BACK PLATE =====
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.beginPath();
      ctx.roundRect(x - 4, y - 4, ICON_SIZE + 8, ICON_SIZE + 8, 8);
      ctx.fill();

    // ===== CLIP ICON (REMOVES BLACK BACKGROUND) =====
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(x, y, ICON_SIZE, ICON_SIZE, 6);
      ctx.clip();

      ctx.drawImage(img, x, y, ICON_SIZE, ICON_SIZE);

      ctx.restore();
    });

    ctx.restore();
  }




  function tryMysteryBox(cost) {
    const box = mysteryBoxes[activeMysteryIndex];
    if (!box || !box.active) return;
    if (player.points < cost) return;

    player.points -= cost;
    mysterySpinCount++;

    const pick =
      MYSTERY_BOX_GUNS[Math.floor(Math.random() * MYSTERY_BOX_GUNS.length)];

    const alreadyOwned = !!player.guns[pick.name];

  // üîí ENFORCE MAX GUNS
    if (!alreadyOwned && ownedGunCount() >= MAX_GUNS) {
      removeCurrentGunIfNeeded();
    }

  // Give gun if not owned
    if (!player.guns[pick.name]) {
      player.guns[pick.name] = structuredClone(pick);
    }

    player.currentGun = player.guns[pick.name];

  // ===== MOVE CHECK =====
    if (mysterySpinCount >= MYSTERY_MOVE_SPINS) {
      mysterySpinCount = 0;

      if (Math.random() < MYSTERY_MOVE_CHANCE) {
        moveMysteryBox();
      }
    }
  }



  function moveMysteryBox() {
    if (mysteryBoxes.length <= 1) return;

    const prevIndex = activeMysteryIndex;

    // üî• HARD RESET ‚Äî only ONE box may be active
    for (const b of mysteryBoxes) {
      b.active = false;
    }

    // build list of valid targets (not the previous one)
    const candidates = mysteryBoxes
      .map((_, i) => i)
      .filter(i => i !== prevIndex);

    // guaranteed different box
    const newIndex =
      candidates[Math.floor(Math.random() * candidates.length)];

    mysteryBoxes[newIndex].active = true;
    activeMysteryIndex = newIndex;
  }



  function restartGame() {
    if (!LOADED_MAP) return;

    // ---- CLEAR ALL RUNTIME ARRAYS ----
    zombies.length = 0;
    bullets.length = 0;
    powerDrops.length = 0;

  // ---- RESET PLAYER ----
    player.alive = true;
    player.downed = false;
    player.hitsMax = 3;
    player.hitsRemaining = 3;
    player.points = 420;
    player.perks = {
      juggernog:false,
      speedCola:false,
      doubleTap:false,
      staminUp:false,
      quickRevive:false,
      quickReviveUsed:false
    };

  // ---- RESET GUNS ----
    player.guns = {};
    player.guns[pistol.name] = structuredClone(pistol);
    player.currentGun = player.guns[pistol.name];

  // ---- RESET ROUND SYSTEM ----
    round = 1;
    roundCooldown = false;
    spawnRemaining = 0;
    aliveCount = 0;

  // ---- RELOAD MAP ----
    loadMap(LOADED_MAP);

  // ---- START ROUND ----
    startRoundSpawns();

  // ---- HIDE GAME OVER ----
    document.getElementById('gameOver').style.display = 'none';
  }



      function updateHealthRegen(dt) {
  // dead or downed players do not regen
  if (!player.alive || player.downed) return;

  // already full health
  if (player.hitsRemaining >= player.hitsMax) return;

  const now = performance.now();

  // wait for delay after last hit
  if (now - player.lastHitTime < player.regenDelay) return;

  // regen amount this frame
  const regenAmount = player.regenRate * dt;

  player.hitsRemaining = Math.min(
    player.hitsMax,
    player.hitsRemaining + regenAmount
  );
}
function hitSlider(slider, mx, my) {
  return (
    mx >= slider.x &&
    mx <= slider.x + slider.width &&
    my >= slider.y - slider.knobRadius &&
    my <= slider.y + slider.height + slider.knobRadius
  );
}


function drawSlider(slider, value) {
  ctx.fillStyle = '#555';
  ctx.fillRect(slider.x, slider.y, slider.width, slider.height);

  ctx.fillStyle = '#1abc9c';
  ctx.fillRect(slider.x, slider.y, slider.width * value, slider.height);

  const knobX = slider.x + slider.width * value;
  const knobY = slider.y + slider.height / 2;

  ctx.beginPath();
  ctx.arc(knobX, knobY, slider.knobRadius, 0, Math.PI * 2);
  ctx.fillStyle = '#fff';
  ctx.fill();
}


function shouldZombieIgnoreBarriers(zombie) {
  const ALIVE_LIMIT_MS = 2 * 60 * 1000; // 2 minutes
  return performance.now() - zombie.spawnTime >= ALIVE_LIMIT_MS;
}



function tryBuyPerk(perk, cost) {

  // =============================
  // QUICK REVIVE (HARD LIMITED)
  // =============================
  if (perk === 'quickRevive') {

    // üö® SOLD OUT = ABSOLUTE STOP
    if (player.quickReviveSoldOut) return;

    // ‚ùå already active (must be used first)
    if (player.perks.quickRevive) return;

    // ‚ùå no buys left
    if (player.quickRevive.buys >= player.quickRevive.maxBuys) {
      player.quickReviveSoldOut = true;
      removeQuickReviveMachine();
      return;
    }

    // ‚ùå not enough points
    if (player.points < cost) return;

    // PAY
    player.points -= cost;

    // COUNT BUY
    player.quickRevive.buys++;

    // ACTIVATE
    player.perks.quickRevive = true;
    player.perks.quickReviveUsed = false;

    // üö® SOLD OUT AFTER 3RD BUY (GUARANTEED)
    if (player.quickRevive.buys === player.quickRevive.maxBuys) {
      player.quickReviveSoldOut = true;
      removeQuickReviveMachine();
    }

    return;
  }

  // =============================
  // NORMAL PERKS
  // =============================
  if (player.perks[perk]) return;
  if (player.points < cost) return;

  player.points -= cost;
  player.perks[perk] = true;

  if (perk === 'juggernog') {
    player.hitsMax = 5;
    player.hitsRemaining = clamp(player.hitsRemaining + 2, 0, player.hitsMax);

  } else if (perk === 'speedCola') {
    for (const g of Object.values(player.guns)) g.reload *= 0.6;

  } else if (perk === 'doubleTap') {
    for (const g of Object.values(player.guns)) {
      g.damage *= 1.15;
      g.fireRate *= 1.15;
    }

  } else if (perk === 'staminUp') {
    player.speed *= 1.5;
  }
}

 function drawPauseOverlay() {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // Dark background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 140);

  ctx.font = '20px system-ui';

  // ===== MASTER VOLUME =====
  ctx.fillText(
    `Gun Volume: ${Math.round(window.MASTER_VOLUME * 100)}%`,
    canvas.width / 2,
    canvas.height / 2 - 80
  );

  masterSlider.x = canvas.width / 2 - masterSlider.width / 2;
  masterSlider.y = canvas.height / 2 - 55;

  drawSlider(masterSlider, window.MASTER_VOLUME);

  // ===== MUSIC VOLUME =====
  ctx.fillText(
    `Music Volume: ${Math.round(window.musicVolume * 100)}%`,
    canvas.width / 2,
    canvas.height / 2 - 10
  );

  musicSlider.x = canvas.width / 2 - musicSlider.width / 2;
  musicSlider.y = canvas.height / 2 + 15;

  drawSlider(musicSlider, window.musicVolume);


  // ===== POWER-UP VOLUME =====
ctx.fillText(
  `Power-Up Volume: ${Math.round(window.powerupVolume * 100)}%`,
  canvas.width / 2,
  canvas.height / 2 + 50
);

powerupSlider.x = canvas.width / 2 - powerupSlider.width / 2;
powerupSlider.y = canvas.height / 2 + 75;

drawSlider(powerupSlider, window.powerupVolume);


  // Footer
  ctx.font = '16px system-ui';
  ctx.fillText('Press ESC to resume', canvas.width / 2, canvas.height / 2 + 125);

  ctx.fillText('-- CONTROLS --', canvas.width / 2, canvas.height / 2 + 155);
  ctx.fillText('W A S D = Move', canvas.width / 2, canvas.height / 2 + 170);
  ctx.fillText('Mouse = Aim', canvas.width / 2, canvas.height / 2 + 185);
  ctx.fillText('Left Click = Shoot', canvas.width / 2, canvas.height / 2 + 200);
  ctx.fillText('R = Reload', canvas.width / 2, canvas.height / 2 + 215);
  ctx.fillText('E = Interact', canvas.width / 2, canvas.height / 2 + 230);
  ctx.fillText('1 = Swap Weapon', canvas.width / 2, canvas.height / 2 + 245);

  ctx.restore();
}





  // Zombie spawning
  function roundZombieHP(r) {
    const base = 100; // base HP round 1
    return Math.floor(base * Math.pow(1.05, r-1));
  }
  function startRoundSpawns() {
    const count = 6 + round*2;     // total per round
    spawnRemaining = count;         // number left to spawn
    spawnTimer = 0;                 // spawn immediately first batch
  }


  // ---------- Rectangle ‚Üî Circle collision helper ----------
  function rectCircleCollide(cx, cy, r, rx, ry, rw, rh) {
    const closestX = clamp(cx, rx, rx + rw);
    const closestY = clamp(cy, ry, ry + rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx * dx + dy * dy) <= r * r;
  }


  function getActiveZombieSpawns() {
    return zombieSpawns.filter(s => {
      if (!s.doorId) return true; // always active

      const door = doors.find(d => d.id === s.doorId);
      return door && door.open;
    });
  }


  function spawnBatch(hp, batchCount) {
  const activeSpawns = zombieSpawns.filter(isSpawnUnlocked);
  if (activeSpawns.length === 0) return;

  for (let i = 0; i < batchCount; i++) {
    const s = activeSpawns[Math.floor(Math.random() * activeSpawns.length)];

    let targetBarrier = null;

    // Assign barrier ONLY if zombie spawns behind it
    if (barriers && barriers.length > 0) {
      for (const b of barriers) {
        if (!b.open && barrierBetweenSpawnAndPlayer(s.x, s.y, b)) {
          targetBarrier = b;
          break;
        }
      }
    }

    zombies.push({
      x: s.x,
      y: s.y,
      r: 12,
      speed: rnd(30, 55),

      hp,
      hpMax: hp,

      // üß† Barrier targeting
      targetBarrier: targetBarrier,
      spawnedBehindBarrier: !!targetBarrier,
      spawnTime: performance.now(),

      attackBarrierDps: 12,
      barrierHitCooldown: 1.5,
      playerHitCooldown: 0,

      // Movement / stuck logic
      lastX: s.x,
      lastY: s.y,
      stuckTime: 0,

      alive: true
    });
  }
}



  function tryUpgradeCurrentGun(stationCost) {
    const g = player.currentGun;
    if (!g) return;

    // safety init
    if (g.upgradeLevel == null) {
      g.upgradeLevel = 0;
      g.baseDamage = g.damage;
      g.baseReserveMax = g.reserveMax;
      g.upgradeCost = 5000;
    }

    const cost = stationCost ?? g.upgradeCost;
    if (player.points < cost) return;

    player.points -= cost;
    upgradeGun(g);
  }




  // Bullets
  function shoot() {
    const g = player.currentGun;
    if (!g) return;

    // ‚õî block firing while reloading
    if (g.reloading) return;

    // üîÅ auto-reload when empty (DO NOT fire)
    if (g.mag <= 0 && g.mag !== Infinity) {
      if (g.reserve > 0) startReload(g);
      playEmptyGunSound();
      return;
    }

    // ‚è±Ô∏è fire rate cooldown
    if (g.cooldown > 0) return;

    const angle = player.angle;
    const speed = g.bulletSpeed;

    bullets.push({
      x: player.x,
      y: player.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      damage: g.damage,
      life: 1.2,
      radius: 3
    });
    playGunSound(g);
    // üî´ consume ammo
    if (g.mag !== Infinity) g.mag--;

    // ‚è≥ reset fire cooldown
    g.cooldown = 1 / g.fireRate;
  }

function updatePowerDrops(now) {
  for (let i = powerDrops.length - 1; i >= 0; i--) {
    const p = powerDrops[i];

    // despawn after 30s
    if (now - p.spawnedAt >= p.lifetime) {
      powerDrops.splice(i, 1);
    }
  }
}



  // Power-up drops
  function tryDropPower(x, y) {
  const chance = 0.12; // ‚úÖ 12% per kill (your comment was right, value was not)
  if (Math.random() > chance) return;

  const weights = [
    { t: 'INSTA',     w: 1.0 },
    { t: 'NUKE',      w: 0.6 },
    { t: '2X',        w: 1.0 },
    { t: 'MAX',       w: 0.9 },
    { t: 'CARPENTER', w: 0.8 },
    { t: 'DEATH',     w: 0.7 }
  ];

  const total = weights.reduce((a, b) => a + b.w, 0);
  let r = Math.random() * total;
  let pick = weights[0].t;

  for (const w of weights) {
    if ((r -= w.w) <= 0) {
      pick = w.t;
      break;
    }
  }

  powerDrops.push({
    type: pick,
    x,
    y,
    r: 16,

    // ‚úÖ FIXED LIFETIME SYSTEM
    spawnedAt: performance.now(),
    lifetime: 30000 // 30 seconds in ms
  });
}




  function pickupPower(p) {
    playPowerupSound(p.type);
    if (p.type === 'INSTA') {
      activePowers.insta = true;
      activePowers.timers.insta = now + 30_000;
    } else if (p.type === '2X') {
      activePowers.double = true;
      activePowers.timers.double = now + 30_000;
    } else if (p.type === 'DEATH') {
      activePowers.death = true;
      activePowers.timers.death = now + 30_000;
      player.prevGunBeforeDeath = player.currentGun;
      player.currentGun = deathMachine;
    } else if (p.type === 'NUKE') {
      for (const z of zombies) if (z.alive) { z.alive=false; awardKill(); tryDropPower(z.x,z.y); }
      // ‚úÖ BONUS POINTS
      player.points += 420;
    } else if (p.type === 'MAX') {
      for (const g of Object.values(player.guns)) {
        if (g.mag !== Infinity) { g.mag = g.magMax; g.reserve = g.reserveMax; }
      }
    } else if (p.type === 'CARPENTER') {
      for (const b of barriers) { b.hp = b.hpMax; b.open = false; }
      // ‚úÖ BONUS POINTS
      player.points += 200;
    }
  }

  function tryBuyDoor(door) {
    if (door.open) return;
    if (player.points < door.cost) return;

    // Pay
    player.points -= door.cost;

    // Open the door
    door.open = true;

    // üî¥ REMOVE THE INTERACT CIRCLE
    for (let i = interacts.length - 1; i >= 0; i--) {
      const it = interacts[i];
      if (it.type === 'door' && it.x === door.x && it.y === door.y) {
        interacts.splice(i, 1);
        break;
      }
    }
  }

  function resolveWallCollision(entity, wall) {
  resolveCircleWallCollision(entity, wall);
}

  
  
  

  // Points
  function awardHit() {
    let pts = 5;
    if (activePowers.double) pts *= 2;
    player.points += pts;
  }
  function awardKill() {
    let pts = 50;
    if (activePowers.double) pts *= 2;
    player.points += pts;
  }
  function awardRepair() {
    let pts = 10;
    if (activePowers.double) pts *= 2;
    player.points += pts;
  }

  // Barrier repair (single tick)
    function repairBarrierTick(b) {
    const add = Math.ceil(b.hpMax * 0.10); // 10%
    const before = b.hp;

  // Allow rebuild from zero
    b.hp = clamp(b.hp + add, 0, b.hpMax);

    if (b.hp > before) {
      awardRepair();
    }

  // Barrier is solid again as soon as HP > 0
    if (b.hp > 0) {
      b.open = false;
    }
  }


  function getSlopeTriangle(wall) {
  const x = wall.x;
  const y = wall.y;
  const w = wall.w;
  const h = wall.h;

  if (wall.slope === 'left') {
    return [
      { x: x,     y: y + h },
      { x: x + w, y: y + h },
      { x: x,     y: y }
    ];
  }

  if (wall.slope === 'right') {
    return [
      { x: x,     y: y + h },
      { x: x + w, y: y + h },
      { x: x + w, y: y }
    ];
  }

  return null;
}


function pointInTriangle(px, py, tri) {
  const [a, b, c] = tri;

  function sign(p1, p2, p3) {
    return (p1.x - p3.x) * (p2.y - p3.y) -
           (p2.x - p3.x) * (p1.y - p3.y);
  }

  const d1 = sign({x: px, y: py}, a, b);
  const d2 = sign({x: px, y: py}, b, c);
  const d3 = sign({x: px, y: py}, c, a);

  const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
  const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

  return !(hasNeg && hasPos);
}



function resolveCircleTriangleCollision(circle, tri) {
  let collided = false;

  // --- EDGE COLLISION ---
  for (let i = 0; i < 3; i++) {
    const a = tri[i];
    const b = tri[(i + 1) % 3];

    const abx = b.x - a.x;
    const aby = b.y - a.y;

    const t = clamp(
      ((circle.x - a.x) * abx + (circle.y - a.y) * aby) /
      (abx * abx + aby * aby),
      0, 1
    );

    const px = a.x + abx * t;
    const py = a.y + aby * t;

    const dx = circle.x - px;
    const dy = circle.y - py;
    const dist = Math.hypot(dx, dy);

    if (dist < circle.radius) {
      const overlap = circle.radius - dist;
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);

      circle.x += nx * overlap;
      circle.y += ny * overlap;

      collided = true;
    }
  }

  // --- INSIDE TRIANGLE FIX (FLIP-SAFE) ---
  if (pointInTriangle(circle.x, circle.y, tri)) {
    let bestPen = Infinity;
    let pushX = 0;
    let pushY = 0;

    for (let i = 0; i < 3; i++) {
      const a = tri[i];
      const b = tri[(i + 1) % 3];

      const ex = b.x - a.x;
      const ey = b.y - a.y;

      // outward normal using triangle winding
      let nx = ey;
      let ny = -ex;

      const len = Math.hypot(nx, ny) || 1;
      nx /= len;
      ny /= len;

      const dist =
        (circle.x - a.x) * nx +
        (circle.y - a.y) * ny;

      // flip normal if pointing inward
      if (dist > 0) {
        nx = -nx;
        ny = -ny;
      }

      const pen = Math.abs(dist);

      if (pen < bestPen) {
        bestPen = pen;
        pushX = nx;
        pushY = ny;
      }
    }

    // push fully out
    circle.x += pushX * (circle.radius + bestPen);
    circle.y += pushY * (circle.radius + bestPen);

    collided = true;
  }

  return collided;
}



  function revivePlayer() {
    player.downed = false;
    player.alive = true;
    

    player.hitsRemaining = player.hitsMax;
    player.lastHitTime = performance.now(); // delay regen briefly after revive


    player.hitsRemaining = player.hitsMax;
    player.reviveTimer = 0;

    if (player.perks.quickRevive) {
      player.perks.quickReviveUsed = true;
    }
    
    if (player.perks.quickRevive) {
      player.quickRevive.level--;

      // quick revive consumed
      player.perks.quickRevive = false;

      if (player.quickRevive.level <= 0) {
        player.quickRevive.level = 0;
      }
    }

    // ===== REVIVE COMPLETE =====
    console.log("PLAYER REVIVED");

    player.downed = false;
    player.alive = true;

// Restore health
    player.hitsMax = player.perks.juggernog ? 5 : 3;
    player.hitsRemaining = player.hitsMax;

// Consume Quick Revive
    player.perks.quickReviveUsed = true;
    player.perks.quickRevive = false;

// üî• 5 SECONDS OF ZOMBIE FEAR
    player.zombieFearTimer = 15;

// Optional safety
    player.lastHitTime = performance.now();

  }




  function updateCamera() {
    const halfW = camera.w / (2 * camera.zoom);
    const halfH = camera.h / (2 * camera.zoom);

    camera.x = player.x - halfW;
    camera.y = player.y - halfH;

    // Clamp camera so it never shows outside the world
    camera.x = clamp(camera.x, 0, WORLD_WIDTH - halfW * 2);
    camera.y = clamp(camera.y, 0, WORLD_HEIGHT - halfH * 2);
  }


  // Interaction (E keydown): prioritize single repair tick, else buy
  function interact() {
    // 1Ô∏è‚É£ Barrier repair has priority
    const nb = nearestDamagedBarrier();
    if (nb) {
      repairBarrierTick(nb);
      return;
    }

    // 2Ô∏è‚É£ Only allow interacts within range
    const INTERACT_RANGE = 60;

    let nearest = null;
    let nd = INTERACT_RANGE;

    for (const i of interacts) {
      const d = Math.hypot(player.x - i.x, player.y - i.y);
      if (d < nd) {
        nd = d;
        nearest = i;
      }
    }

    if (nearest) {
      nearest.action(nearest);
    }
  }


  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'r') {
      startReload(player.currentGun);
    }
  });


  window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if (k === 'e') interact();
    

  });

  function nearestDamagedBarrier() {
    let best = null;
    let bd = Infinity;

    for (const b of barriers) {
      if (b.hp >= b.hpMax) continue; // only skip FULL barriers

      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;
      const d = Math.hypot(player.x - cx, player.y - cy);

      if (d < 60 && d < bd) {
        bd = d;
        best = b;
      }
    }
    return best;
  }


  for (const d of doors) {
    if (!d.open) {
      resolveCircleWallCollision(player, d);
      for (const z of zombies) resolveCircleWallCollision(z, d);
    }
  }


  function drawSlopeWallGame(w) {
  const x1 = w.x - w.w / 2;
  const x2 = w.x + w.w / 2;
  const y1 = w.y - w.h / 2;
  const y2 = w.y + w.h / 2;

  ctx.fillStyle = '#555';
  ctx.beginPath();

  const flipped = w.flip === true;

  switch (w.slope) {

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LEFT SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'left':
      if (!flipped) {
        // normal
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x1, y1);
      } else {
        // flipped (upside down)
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x1, y2);
      }
      break;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RIGHT SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'right':
      if (!flipped) {
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x2, y1);
      } else {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x2, y2);
      }
      break;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UP SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'up':
      if (!flipped) {
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x2, y1);
      } else {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x1, y2);
      }
      break;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DOWN SLOPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    case 'down':
      if (!flipped) {
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y1);
        ctx.lineTo(x1, y2);
      } else {
        ctx.moveTo(x1, y2);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x2, y1);
      }
      break;

    default:
      return;
  }

  ctx.closePath();
  ctx.fill();
}




  function resolveCircleSlopeCollision(entity, wall, r) {
  const x = wall.x - wall.w / 2;
  const y = wall.y - wall.h / 2;
  const w = wall.w;
  const h = wall.h;

  const flipped = wall.flip === true;

  // Define triangle points (MATCHES DRAW LOGIC)
  let tri;

  if (wall.slope === 'left') {
    if (!flipped) {
      // normal left slope
      tri = [
        { x: x,     y: y + h },
        { x: x + w, y: y + h },
        { x: x,     y: y }
      ];
    } else {
      // flipped left slope (upside down)
      tri = [
        { x: x,     y: y },
        { x: x + w, y: y },
        { x: x,     y: y + h }
      ];
    }
  }

  else if (wall.slope === 'right') {
    if (!flipped) {
      // normal right slope
      tri = [
        { x: x,     y: y + h },
        { x: x + w, y: y + h },
        { x: x + w, y: y }
      ];
    } else {
      // flipped right slope (upside down)
      tri = [
        { x: x,     y: y },
        { x: x + w, y: y },
        { x: x + w, y: y + h }
      ];
    }
  } else {
    return;
  }

  // Edge-by-edge circle vs triangle
  for (let i = 0; i < 3; i++) {
    const a = tri[i];
    const b = tri[(i + 1) % 3];

    const abx = b.x - a.x;
    const aby = b.y - a.y;

    const t = clamp(
      ((entity.x - a.x) * abx + (entity.y - a.y) * aby) /
      (abx * abx + aby * aby),
      0, 1
    );

    const px = a.x + abx * t;
    const py = a.y + aby * t;

    const dx = entity.x - px;
    const dy = entity.y - py;
    const dist = Math.hypot(dx, dy);

    if (dist < r) {
      const overlap = r - dist;
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);

      entity.x += nx * overlap;
      entity.y += ny * overlap;
    }
  }
}




  function resolveCircleWallCollision(entity, wall) {
  const r = entity.r || entity.radius || 12;

  // üî∫ SLOPE WALLS (TRIANGLES)
  if (wall.slope === 'left' || wall.slope === 'right') {
    resolveCircleSlopeCollision(entity, wall, r);
    return;
  }

  // üü¶ NORMAL RECT WALLS (unchanged logic)
  const left   = wall.x - wall.w / 2;
  const right  = wall.x + wall.w / 2;
  const top    = wall.y - wall.h / 2;
  const bottom = wall.y + wall.h / 2;

  const closestX = clamp(entity.x, left, right);
  const closestY = clamp(entity.y, top, bottom);

  const dx = entity.x - closestX;
  const dy = entity.y - closestY;

  const distSq = dx * dx + dy * dy;

  if (distSq < r * r) {
    const dist = Math.sqrt(distSq) || 0.0001;
    const overlap = r - dist;

    entity.x += (dx / dist) * overlap;
    entity.y += (dy / dist) * overlap;
  }
}



  // ---------- NEW: Collision helpers ----------
  // Prevent circular entities from entering solid (unbroken) barrier rectangles
  function resolveEntityBarrierCollision(entity, barrier) {
    if (barrier.open) return; // pass-through when broken
    const e = entity;
    const r = e.r || e.radius || 12;
    // Inflate barrier by entity radius for simple AABB collision
    const bx = barrier.x - r;
    const by = barrier.y - r;
    const bw = barrier.w + 2*r;
    const bh = barrier.h + 2*r;

    // If entity center is inside inflated rect, push to nearest edge
    if (e.x >= bx && e.x <= bx + bw && e.y >= by && e.y <= by + bh) {
      // Distances to edges
      const leftDist   = Math.abs(e.x - bx);
      const rightDist  = Math.abs((bx + bw) - e.x);
      const topDist    = Math.abs(e.y - by);
      const bottomDist = Math.abs((by + bh) - e.y);
      const minDist = Math.min(leftDist, rightDist, topDist, bottomDist);

      if (minDist === leftDist) {
        e.x = bx;
      } else if (minDist === rightDist) {
        e.x = bx + bw;
      } else if (minDist === topDist) {
        e.y = by;
      } else {
        e.y = by + bh;
      }
    }
  }


    function rectIntersect(a, b) {
      return (
        a.x - a.w / 2 < b.x + b.w / 2 &&
        a.x + a.w / 2 > b.x - b.w / 2 &&
        a.y - a.h / 2 < b.y + b.h / 2 &&
        a.y + a.h / 2 > b.y - b.h / 2
      );
    }


    function rayHitsWall(x, y, dx, dy, dist) {
      const steps = 6;
      const step = dist / steps;

      for (let i = 1; i <= steps; i++) {
        const px = x + dx * step * i;
        const py = y + dy * step * i;

        for (const w of walls) {
          const left   = w.x - w.w / 2;
          const right  = w.x + w.w / 2;
          const top    = w.y - w.h / 2;
          const bottom = w.y + w.h / 2;

          if (px > left && px < right && py > top && py < bottom) {
            return true;
          }
        }

        for (const b of barriers) {
          if (b.open) continue;
          if (px > b.x && px < b.x + b.w && py > b.y && py < b.y + b.h) {
            return true;
          }
        }
      }

      return false;
    }


  



  function drawWeaponHUD() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const padding = 50;
  const hudW = 200;
  const hudH = 90;

  const x = canvas.width - hudW - padding;
  const y = canvas.height - hudH - padding;

  ctx.save();

  // ===============================
  // ‚ù§Ô∏è HEALTH BAR (ALWAYS DRAWS)
  // ===============================
  const barWidth = hudW - 30;
  const barHeight = 10;
  const barX = x + 15;
  const barY = y + hudH + 10;

  const healthPct = Math.max(
    0,
    Math.min(1, player.hitsRemaining / player.hitsMax)
  );

  // background
  ctx.fillStyle = '#222';
  ctx.fillRect(barX, barY, barWidth, barHeight);

  // color based on health
  if (healthPct <= 0.3) {
    ctx.fillStyle = '#e74c3c'; // red
  } else if (healthPct <= 0.6) {
    ctx.fillStyle = '#f1c40f'; // yellow
  } else {
    ctx.fillStyle = '#2ecc71'; // green
  }

  // fill
  ctx.fillRect(barX, barY, barWidth * healthPct, barHeight);

  // border
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 2;
  ctx.strokeRect(barX, barY, barWidth, barHeight);

  // ===============================
  // üî´ WEAPON HUD (SAFE TO EXIT)
  // ===============================
  const g = player.currentGun;
  if (!g) {
    ctx.restore();
    return;
  }

  // üî¥ Blood streak background
  ctx.fillStyle = '#8b0000';
  ctx.beginPath();
  ctx.moveTo(x + 22, y);
  ctx.lineTo(x + hudW, y);
  ctx.lineTo(x + hudW - 22, y + hudH);
  ctx.lineTo(x, y + hudH);
  ctx.closePath();
  ctx.fill();

  // üî´ AMMO (CENTER)
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 36px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  const ammo = g.mag === Infinity ? '‚àû' : g.mag;
  ctx.fillText(ammo, x + hudW / 2, y + hudH / 2 - 6);

  // üßÆ RESERVE
  if (g.mag !== Infinity) {
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#ddd';
    ctx.fillText(
      g.reserve,
      x + hudW / 2 + 55,
      y + hudH / 2 - 6
    );
  }

  // ‚≠ê UPGRADE LEVEL
  if (g.upgradeLevel && g.upgradeLevel > 0) {
    ctx.font = 'bold 13px sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.fillText(
      `UPG ${g.upgradeLevel}`,
      x + hudW / 2,
      y + hudH - 30
    );
  }

  // üî§ GUN NAME
  ctx.font = '14px sans-serif';
  ctx.fillStyle = '#eee';
  ctx.fillText(
    g.name.toUpperCase(),
    x + hudW / 2,
    y + hudH - 15
  );

  ctx.restore();
}


  function drawPointsHUD() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    const paddingX = 50;
    const paddingY = 50;

    const hudW = 145;
    const hudH = 40;

  // position ABOVE weapon HUD
    const weaponHudH = 90;
    const gap = 10;

    const x = canvas.width - hudW - paddingX;
    const y = canvas.height - weaponHudH - hudH - paddingY - gap;

    ctx.save();

  // üî¥ Blood streak background (smaller)
    ctx.fillStyle = '#8b0000';
    ctx.beginPath();
    ctx.moveTo(x + 18, y);
    ctx.lineTo(x + hudW, y);
    ctx.lineTo(x + hudW - 18, y + hudH);
    ctx.lineTo(x, y + hudH);
    ctx.closePath();
    ctx.fill();

    // üí∞ Points value
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    ctx.fillText(
      player.points,
      x + hudW / 2,
      y + hudH / 2.5
    );

    // Optional label
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#eee';
    ctx.fillText(
    'SUS',
      x + hudW / 2,
      y + hudH - 7
    );

    ctx.restore();
  }




    function resolvePlayerBarrierCollision(player, barrier) {
      const r = player.radius;

      // Closest point on rectangle to player center
      const closestX = clamp(player.x, barrier.x, barrier.x + barrier.w);
      const closestY = clamp(player.y, barrier.y, barrier.y + barrier.h);

      const dx = player.x - closestX;
      const dy = player.y - closestY;

      const distSq = dx * dx + dy * dy;

      // If overlapping
      if (distSq < r * r) {
        const dist = Math.sqrt(distSq) || 0.0001;
        const overlap = r - dist;

        // Push player out along collision normal
        player.x += (dx / dist) * overlap;
        player.y += (dy / dist) * overlap;
      }
    }

    function resolveAllBarrierCollisionsForEntity(entity, canPassWhenOpen) {
      for (const b of barriers) {
        if (b.open && canPassWhenOpen) continue;

        const r = entity.r || entity.radius || 12;

        const closestX = clamp(entity.x, b.x, b.x + b.w);
        const closestY = clamp(entity.y, b.y, b.y + b.h);

        const dx = entity.x - closestX;
        const dy = entity.y - closestY;

        const distSq = dx * dx + dy * dy;
        if (distSq < r * r) {
          const dist = Math.sqrt(distSq) || 0.0001;
          const overlap = r - dist;

          entity.x += (dx / dist) * overlap;
          entity.y += (dy / dist) * overlap;
        }

        for (const z of zombies) {
          for (const b of barriers) {
            if (!b.open) {
              resolveCircleRotatedRectCollision(zombie, b);
            }
          }
        }


        for (const b of barriers) {
          if (!b.open) {
            resolveCircleRotatedRectCollision(player, b);
          }
        }

      }
    }

    function clampCamera() {
      const halfW = camera.w / (2 * camera.zoom);
      const halfH = camera.h / (2 * camera.zoom);

      camera.x = Math.max(halfW, Math.min(WORLD_WIDTH - halfW, camera.x));
      camera.y = Math.max(halfH, Math.min(WORLD_HEIGHT - halfH, camera.y));
}


  function maybeDropPowerUp(x, y) {
    // Base drop chance (classic zombies feel)
    if (Math.random() > 0.15) return; // 15% overall drop chance

    const rarity = rollDropRarity(round);
    if (!rarity) return;

    const pool = DROP_RARITIES[rarity].drops;
    const type = pool[Math.floor(Math.random() * pool.length)];

    powerDrops.push({
     x,
      y,
      r: 16,
      type,
      rarity,
      spawnTime: performance.now()
    });
  }


  // -------------------------------------------


  
  // Game loop timing
  let lastTime = performance.now();
  let now = lastTime;

  // Start first round
  startRoundSpawns();

  function update(dt) {
    // Update player aim
    const mw = getMouseWorldPos();
    const mouseWorldX = mouse.x + camera.x;
    const mouseWorldY = mouse.y + camera.y;
    const now = performance.now();

    const worldMouse = screenToWorld(mouse.x, mouse.y);
    player.angle = Math.atan2(worldMouse.y - player.y, worldMouse.x - player.x);
    


    updateReloads(dt);
    updateHealthRegen(dt);
    updatePowerDrops(now);




    
// ===============================
// DOWNED / QUICK REVIVE SYSTEM
// ===============================
if (player.downed) {
  // countdown (dt is already seconds)
  player.reviveTimer -= dt;
  resetAllPerkEffects();

  // clamp
  if (player.reviveTimer < 0) player.reviveTimer = 0;

  // finished reviving
  if (player.reviveTimer === 0) {
    revivePlayer();
  }

  // stop all movement / combat while downed
  return;
}


// ENTER DOWNED STATE (run ONCE)
// ===== PLAYER DOWNED LOGIC (FIXED) =====
if (player.hitsRemaining <= 0 && !player.downed) {

  // QUICK REVIVE AVAILABLE
  if (player.perks.quickRevive && !player.perks.quickReviveUsed) {

    player.downed = true;
    player.alive = false;

    // üî• START REVIVE
    player.reviveDuration = 5;
    player.reviveTimer = player.reviveDuration;



  } else {
    // NO QUICK REVIVE ‚Üí GAME OVER
    player.alive = false;
    gameOver();
  }
}







// ===== QUICK REVIVE TIMER =====
    if (player.downed) {

      player.reviveTimer -= dt;
      resetAllPerkEffects();

      if (player.reviveTimer <= 0) {

        // üî• STAND BACK UP
        player.downed = false;
        player.alive = true;

        // Restore health
        player.hitsMax = player.perks.juggernog ? 5 : 3;

    // Consume Quick Revive
        player.perks.quickReviveUsed = true;
        player.perks.quickRevive = false;

    // Safety reset
        player.reviveTimer = 0;
  }

      return; // ‚õî Skip normal gameplay while downed
    }


    // ===== POWER-UP TIMERS =====
    if (activePowers.insta && now > activePowers.timers.insta) {
      activePowers.insta = false;
    }

    if (activePowers.double && now > activePowers.timers.double) {
      activePowers.double = false;
    }

    if (activePowers.death && now > activePowers.timers.death) {
      activePowers.death = false;

      // restore previous gun
      if (player.prevGunBeforeDeath) {
        player.currentGun = player.prevGunBeforeDeath;
        player.prevGunBeforeDeath = null;
      }
    }

    

    // üö™ PLAYER vs DOORS
    for (const d of doors) {
      if (!d.open) {
        resolveCircleRotatedRectCollision(player, d);
      }
    }


    // Zombies vs walls
    for (const z of zombies) {
      if (!z.alive) continue;

      for (const d of doors) {
        if (!d.open) {
          resolveCircleWallCollision(z, d);
        }
      }


      for (const w of walls) {
        resolveCircleWallCollision(z, w);
      }
      // üö™ ZOMBIE vs DOORS
      for (const d of doors) {
        if (!d.open) {
          resolveCircleRotatedRectCollision(z, d);
        }
      }
      handleZombieStuck(z, dt);
    }

    

    // Player vs walls
    for (const wall of walls) {

  if (wall.slope) {
    // üî∫ slope collision
    const rPlayer = player.r || player.radius || 12;
    resolveCircleSlopeCollision(player, wall, rPlayer);

    for (const z of zombies) {
      const rZ = z.r || z.radius || 12;
      resolveCircleSlopeCollision(z, wall, rZ);
    }

  } else {
    // üß± normal wall collision
    resolveWallCollision(player, wall);

    for (const z of zombies) {
      resolveWallCollision(z, wall);
    }
  }
}


    


    // Handle round cooldown timer
    if (roundCooldown && now >= roundCooldownEnd) {
      roundCooldown = false;
      showRoundBanner = false;
      startRoundSpawns();
    }

    for (const z of zombies) {
      for (const b of barriers) {

        // ‚è±Ô∏è Barrier timeout check
        if (z.spawnedBehindBarrier && shouldZombieIgnoreBarriers(z)) {
          z.spawnedBehindBarrier = false;
          z.targetBarrier = null;
          z.blockedByBarrier = null;
        }

        if (b.hp <= 0) continue; // only ignore broken barriers

        if (
          rectCircleCollide(
          z.x, z.y, z.r,
          b.x, b.y, b.w, b.h
          )
        ) {
          // PUSH ZOMBIE OUT (same as player logic)
          const cx = b.x + b.w / 2;
          const cy = b.y + b.h / 2;

          const dx = z.x - cx;
          const dy = z.y - cy;

          const overlapX = b.w / 2 + z.r - Math.abs(dx);
          const overlapY = b.h / 2 + z.r - Math.abs(dy);

          if (overlapX < overlapY) {
            z.x += dx > 0 ? overlapX : -overlapX;
          } else {
            z.y += dy > 0 ? overlapY : -overlapY;
          }

          // STOP zombie movement when colliding
          z.blockedByBarrier = b;
        }
      }
    }

    for (const t of zombieTraps) {

      // ‚è≥ delayed activation
      if (t.pending && now >= t.activateAt) {
        t.pending = false;
        t.active = true;
        t.activeUntil = now + t.duration * 1000;
      }

      // ‚è±Ô∏è auto shutoff ‚Üí cooldown
      if (t.active && now >= t.activeUntil) {
        t.active = false;
        t.cooldownUntil = now + t.cooldown * 1000;
        continue;
      }

      // ‚õî cooldown lock
      if (now < t.cooldownUntil) continue;

      // ‚õî inactive
      if (!t.active) continue;

      // üî• zombies
      for (const z of zombies) {
        if (!z.alive) continue;

        if (
          circleRectHit(
            z.x, z.y, z.r,
            t.x - t.w / 2,
            t.y - t.h / 2,
            t.w,
            t.h
          )
        ) {
          z.alive = false;
          player.points += 25;
        }
      }

  // ‚ò†Ô∏è PLAYER DAMAGE FROM TRAP
  if (
    circleRectHit(
     player.x, player.y, player.radius,
      t.x - t.w / 2,
      t.y - t.h / 2,
      t.w,
      t.h
    )
  ) {
    if (now >= player.trapDamageImmunityUntil) {

      player.trapDamageImmunityUntil = now + 300;
      player.lastHitTime = now;

      if (player.perks.juggernog) {
      // üî• NEW RULE
        if (player.hitsRemaining < 5) {
          player.hitsRemaining = 0; // instant down
        } else {
          player.hitsRemaining = 1; // barely survive
        }
      } else {
        player.hitsRemaining = 0;
      }

    }
  }
      }




    function updateReloads(dt) {
      const g = player.currentGun;
      if (!g || !g.reloading) return;

      g.reloadTimer -= dt;

      if (g.reloadTimer > 0) return;

      const needed = g.magMax - g.mag;
      const taken = Math.min(needed, g.reserve);

      g.mag += taken;
      g.reserve -= taken;

      g.reloading = false;
      g.reloadTimer = 0;
    }



    // Downed / revive handling: block movement & shooting, count down timer
    // ===== DOWNED LOGIC =====
  // ===== DOWNED / REVIVE LOGIC (FIXED) =====
// ===== DOWNED / QUICK REVIVE LOGIC (FINAL FIX) =====




    
    // Movement
    let vx=0, vy=0;
    if (keys['w']) vy -= 1;
    if (keys['s']) vy += 1;
    if (keys['a']) vx -= 1;
    if (keys['d']) vx += 1;
    if (vx !== 0 || vy !== 0) {
      const len = Math.hypot(vx,vy);
      vx /= len; vy /= len;
    }
    

    //---
    const speed = player.speed;
    updateReloads(dt);

    // save previous position (used by collision resolution)
    player.prevX = player.x;
    player.prevY = player.y;

    // APPLY MOVEMENT
    player.x += vx * speed * dt;
    player.y += vy * speed * dt;

    // CLAMP TO WORLD (not screen)
    player.x = clamp(player.x, 20, WORLD_WIDTH - 20);
    player.y = clamp(player.y, 20, WORLD_HEIGHT - 20);


    player.x = clamp(player.x, 20, WORLD_WIDTH - 20);
    player.y = clamp(player.y, 20, WORLD_HEIGHT - 20);


    // ---------- NEW: Zombie vs Zombie collision ----------
    for (let i = 0; i < zombies.length; i++) {
      const z1 = zombies[i];
      if (!z1.alive) continue;

      for (let j = i + 1; j < zombies.length; j++) {
        const z2 = zombies[j];
        if (!z2.alive) continue;

        resolveCircleCollision(z1, z2);
      }
      
    }

    

    

// ---------------------------------------------------

    // ---------- NEW: Player vs barrier collision ----------
    for (const b of barriers) {resolvePlayerBarrierCollision(player, b);}


    // ------------------------------------------------------

    // Shooting / reload
    const g = player.currentGun;
    if (g) {
      if (g.cooldown > 0) g.cooldown = Math.max(0, g.cooldown - dt);
      if (mouse.down) {
        if (g.auto) shoot(); else { shoot(); mouse.down = false; }
      }
    }

    // Health regen after 15s no hit
    const regenDelay = 15000 / player.quickRevive.regenMultiplier;



    // Hold E to repair: 10% per second up to 10 seconds per hold
    if (keys['e']) {
      const b = nearestDamagedBarrier();

        if (b && b.hp > 0) {
          if (player.repairing.barrier !== b) {
            player.repairing.barrier = b;
            player.repairing.timer = 0;
            player.repairing.ticks = 0;
          }

          player.repairing.timer += dt;

          while (
            player.repairing.timer >= 1 &&
            player.repairing.ticks < 10 &&
            b.hp > 0 &&
            b.hp < b.hpMax
          ) {
            player.repairing.timer -= 1;
            player.repairing.ticks++;
            repairBarrierTick(b);
          }
        } else {
          player.repairing.barrier = null;
          player.repairing.timer = 0;
          player.repairing.ticks = 0;
        }
      }


    // Update barriers open state
    for (const b of barriers) b.open = (b.hp <= 0);

    // Batch spawns
    if (!roundCooldown && spawnRemaining > 0) {
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        const batch = Math.min(spawnRemaining, Math.floor(rnd(2,4)));
        spawnBatch(roundZombieHP(round), batch);
        spawnRemaining -= batch;
        spawnTimer = rnd(1.0, 2.5);
      }
    }

    // Update zombies


    


  

    aliveCount = 0;
    for (const z of zombies) {
      if (!z.alive) continue;
      aliveCount++;

      // Target barrier center if intact on their side; else player
      // ---------- Zombie targeting ----------
      let targetX = player.x;
      let targetY = player.y;

      // Distance to player
      const dxp = player.x - z.x;
      const dyp = player.y - z.y;
      const distPlayer = Math.hypot(dxp, dyp);

      const fearing = player.zombieFearTimer > 0;

        if (fearing) {
          // Run away from player
          const dx = z.x - player.x;
          const dy = z.y - player.y;
          const len = Math.hypot(dx, dy) || 1;

          targetX = z.x + (dx / len) * 100;
          targetY = z.y + (dy / len) * 100;
        } else {
          // Normal chase
          targetX = player.x;
          targetY = player.y;
        }

      // Assume player by default
      let chasingPlayer = true;

      const b = z.targetBarrier;
      // ===============================
// ZOMBIE ‚Üí BARRIER / PLAYER LOGIC
// ===============================

// Default: chase player

// Only consider barriers if this zombie spawned behind one
if (
  z.spawnedBehindBarrier &&
  z.targetBarrier &&
  !z.targetBarrier.open
) {
  const b = z.targetBarrier;

  const bx = b.x + b.w / 2;
  const by = clamp(z.y, b.y, b.y + b.h);

  const distBarrier = Math.hypot(z.x - bx, z.y - by);

  // If barrier is closer than player ‚Üí attack barrier
  if (distBarrier < distPlayer) {
    chasingPlayer = false;
    targetX = bx;
    targetY = by;

    // ----- Barrier attack logic -----
    // ----- Barrier attack logic -----
    if (distBarrier <= 22) {

  // ‚õî Safety guard ‚Äî expired / invalid zombies cannot hit barriers
      if (!z.spawnedBehindBarrier || !z.targetBarrier) continue;

      z.blockedByBarrier = b;

      z.barrierHitCooldown -= dt;
      if (z.barrierHitCooldown <= 0) {
        b.hp -= z.attackBarrierDps;
        z.barrierHitCooldown = 1.5;

        if (b.hp <= 0) {
          b.hp = 0;
          b.open = true;
          z.blockedByBarrier = null;
        }
      }

  // Stop movement ONLY when attacking barrier
  z.skipMove = true;
}

  }
}

// If not attacking barrier ‚Üí chase player
if (chasingPlayer) {
  targetX = player.x;
  targetY = player.y;
}


      if (player.zombieFearTimer > 0) {
        player.zombieFearTimer -= dt;
        if (player.zombieFearTimer < 0) {
          player.zombieFearTimer = 0;
        }
      }


      // ---------- Zombie Fear (unchanged) ----------
      // ---------- Zombie Fear (FIXED) ----------
      if (player.zombieFearTimer > 0) {

        // Run directly away from player
        const dx = z.x - player.x;
        const dy = z.y - player.y;
        const len = Math.hypot(dx, dy) || 1;

        const fleeSpeed = z.speed * 1.1; // slight boost, optional

        z.x += (dx / len) * fleeSpeed * dt;
        z.y += (dy / len) * fleeSpeed * dt;

      } else {
        // Normal zombie behavior continues below
      }


      // ===============================
      // ‚ù§Ô∏è HEALTH REGEN SYSTEM
      // ===============================
      if (
        player.alive &&
        !player.downed &&
        player.hitsRemaining < player.hitsMax
      ) {
        const now = performance.now();

        if (now - player.lastHitTime >= player.regenDelay) {
          const regenAmount = player.regenRate * (dt / 1000);
          player.hitsRemaining = Math.min(
          player.hitsMax,
          player.hitsRemaining + regenAmount
        );
      }
    }


      // ---------- Move toward chosen target ----------
      if (!z.skipMove) {
        const dx = targetX - z.x;
        const dy = targetY - z.y;
        const dist = Math.hypot(dx, dy);

        if (dist > 0) {
          z.x += (dx / dist) * z.speed * dt;
          z.y += (dy / dist) * z.speed * dt;
        }
      }

      z.skipMove = false;


      resolveCircleCollision(player, z);

      // ---------- NEW: Zombie vs barrier collision ----------
    if (z.blockedByBarrier) {
      z.barrierHitCooldown -= dt;

      if (z.barrierHitCooldown <= 0) {
        z.blockedByBarrier.hp -= z.attackBarrierDps;
        z.barrierHitCooldown = 1.5;

        if (z.blockedByBarrier.hp <= 0) {
          z.blockedByBarrier.hp = 0;
          z.blockedByBarrier.open = true;
        }
      }

      continue; // DO NOT MOVE THROUGH
    }

      // ------------------------------------------------------

      // If near player, deal hits intermittently
    const playerReach = 26;
    const d2p = Math.hypot(z.x - player.x, z.y - player.y);
    if (player.downed) continue;
    if (player.downed) return;
    

    if (d2p <= playerReach) {
        z.playerHitCooldown -= dt;
        if (player.downed) continue;
        if (player.downed) return;

    if (z.playerHitCooldown <= 0) {
        player.lastHitTime = now;
        if (player.downed) return;
        if (player.downed) continue;
        // ‚õî ignore zombie damage briefly after trap hit
        if (now < player.trapDamageImmunityUntil) continue;

        player.hitsRemaining--;
        player.lastHitTime = performance.now(); // üî• REQUIRED


        z.playerHitCooldown = 1.0;

    // ===== PLAYER DOWNED LOGIC (FIXED) =====



        }
      }
    }

    // Round progression
    // Round progression
    if (aliveCount === 0 && spawnRemaining === 0 && !roundCooldown) {
      round += 1;
      startRoundCooldown();
    }


    //----------------
    camera.x = clamp(
      player.x - camera.w / 2,
      0,
      WORLD_WIDTH - camera.w
    );

    camera.y = clamp(
      player.y - camera.h / 2,
      0,
      WORLD_HEIGHT - camera.h
    );

    // ---------- BULLETS ----------
    for (const bullet of bullets) {
      bullet.x += bullet.vx * dt;
      bullet.y += bullet.vy * dt;
      bullet.life -= dt;
    }

    // ---------- BULLET vs ZOMBIE DAMAGE ----------
    for (const bullet of bullets) {
      if (bullet.life <= 0) continue;

      for (const z of zombies) {
        if (!z.alive) continue;

        const dx = bullet.x - z.x;
        const dy = bullet.y - z.y;
        const hitDist = z.r + 2;

        if (dx * dx + dy * dy <= hitDist * hitDist) {
          // ‚úÖ DAMAGE APPLIED
          const dmg = activePowers.insta ? z.hp : bullet.damage;
          z.hp -= dmg;
          bullet.life = 0;

          if (z.hp <= 0) {
            z.alive = false;
            awardKill();
            tryDropPower(z.x, z.y);
            maybeDropPowerUp(z.x, z.y);
          }
          break;
        }
      }
    }

    // remove dead bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      let hitWall = false;

      // ---- SOLID WALLS ----
      for (const w of walls) {
        if (bulletHitsRect(b, w)) {
          hitWall = true;
          break;
        }
      }


      if (hitWall) {
        bullets.splice(i, 1);
        continue;
      }

      // ---- LIFETIME ----
      b.life -= dt;
      if (b.life <= 0) {
        bullets.splice(i, 1);
      }
    }





    // Power-ups floor lifetime & pickup
    for (let i=powerDrops.length-1;i>=0;i--) {
      const p = powerDrops[i];
      if ((now - p.created) / 1000 >= p.ttl) { powerDrops.splice(i,1); continue; }
      const d = Math.hypot(player.x - p.x, player.y - p.y);
      if (d < 22) {
        pickupPower(p);
        powerDrops.splice(i,1);
      }
    }

    // Power-up effect timers
    if (activePowers.insta && now >= activePowers.timers.insta) activePowers.insta=false;
    if (activePowers.double && now >= activePowers.timers.double) activePowers.double=false;
    if (activePowers.death && now >= activePowers.timers.death) {
      activePowers.death=false;
      if (player.prevGunBeforeDeath) player.currentGun = player.prevGunBeforeDeath;
      player.prevGunBeforeDeath = null;
    }

    // Update UI
    uiRound.textContent = round;
    uiZombiesLeft.textContent = aliveCount
      ? `${player.currentGun.name} [UPG ${player.currentGun.upgradeLevel}]`
      : 'None';


    const powersActive = [];
    if (activePowers.insta) powersActive.push('Insta-Kill');
    if (activePowers.double) powersActive.push('2x Points');
    if (activePowers.death) powersActive.push('Death Machine');
    const perksActive = Object.entries(player.perks)
      .filter(([k,v])=>v && k!=='quickReviveUsed')
      .map(([k])=>(k==='quickReviveUsed')?'':k)
      .map(k => ({
        juggernog:'Juggernog',
        speedCola:'Speed Cola',
        doubleTap:'Double Tap',
        staminUp:'Stamin-Up',
        quickRevive:'Quick Revive'
      }[k]))
      .filter(Boolean);

    
  }


  function screenToWorld(x, y) {
    return {
      x: x / camera.zoom + camera.x,
      y: y / camera.zoom + camera.y
    };
  }


  function getMouseWorldPos() {
    return {
      x: mouse.x / camera.zoom + camera.x,
      y: mouse.y / camera.zoom + camera.y
    };
  }



  

// ================================
// üéµ BACKGROUND MUSIC MANAGER
// ================================
const MusicPlayer = {
  playlist: [
    'assets/music/song1.mp3',
    'assets/music/song2.mp3',
    'assets/music/song3.mp3',
    'assets/music/song4.mp3',
    'assets/music/song5.mp3',
    'assets/music/song6.mp3',
    'assets/music/song7.mp3',
    'assets/music/song8.mp3',
    'assets/music/song9.mp3',
    'assets/music/song10.mp3',
    'assets/music/song11.mp3',
    'assets/music/song12.mp3',
    'assets/music/song13.mp3',
  ],

  audio: new Audio(),
  currentIndex: 0,
  shuffle: true,
  playedIndices: [],

  init() {
    // register this as the active music source
    window.currentMusic = this.audio;

    this.audio.loop = false;
    this.applyVolume();

    this.audio.addEventListener('ended', () => this.playNext());
  },

  applyVolume() {
    const music = window.musicVolume ?? 0.6;
    const master = window.MASTER_VOLUME ?? 1;

    this.audio.volume = music * master;
  },

  setVolume(v) {
    window.musicVolume = Math.max(0, Math.min(1, v));
    this.applyVolume();
  },

  play() {
    if (!this.audio.src) {
      this.pickNextIndex();
      this.audio.src = this.playlist[this.currentIndex];
    }

    this.applyVolume();
    this.audio.play();
  },

  pause() {
    this.audio.pause();
  },

  stop() {
    this.audio.pause();
    this.audio.currentTime = 0;
  },

  toggleShuffle() {
    this.shuffle = !this.shuffle;
    console.log('Shuffle:', this.shuffle ? 'ON' : 'OFF');
  },

  pickNextIndex() {
    if (this.shuffle) {
      if (this.playedIndices.length >= this.playlist.length) {
        this.playedIndices = [];
      }

      let next;
      do {
        next = Math.floor(Math.random() * this.playlist.length);
      } while (this.playedIndices.includes(next));

      this.playedIndices.push(next);
      this.currentIndex = next;
    } else {
      this.currentIndex = (this.currentIndex + 1) % this.playlist.length;
    }
  },

  playNext() {
    this.pickNextIndex();
    this.audio.src = this.playlist[this.currentIndex];
    this.applyVolume();
    this.audio.play();
  }
};

// Initialize once
MusicPlayer.init();


  




  function draw() {
    // ‚úÖ ALWAYS start clean
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    updateCamera();

    // ‚úÖ APPLY CAMERA ONCE
    ctx.save();

    // Apply camera transform
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);
    
    for (const d of doors) {
      if (d.open) continue;

      ctx.save();
      ctx.translate(d.x, d.y);
      ctx.rotate((d.rotation || 0) * Math.PI / 180);
      ctx.fillStyle = '#7b5';
      ctx.fillRect(-d.w/2, -d.h/2, d.w, d.h);
      ctx.restore();
    }



    // Map background
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    if (SHOW_WORLD_BORDER) {
      drawWorldBorder();
    }



    for (const t of zombieTraps) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.rotate((t.rotation || 0) * Math.PI / 180);

      ctx.fillStyle = t.active ? '#ff0000' : '#550000';
      ctx.fillRect(-t.w / 2, -t.h / 2, t.w, t.h);

      if (t.active) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(-t.w / 2, -t.h / 2, t.w, t.h);
      }

      ctx.restore();
    }



   // =====================
// Draw walls (center-based, rotated)
// =====================
for (const w of walls) {
  ctx.save();
  ctx.translate(w.x, w.y);
  ctx.rotate((w.rotation || 0) * Math.PI / 180);

  ctx.fillStyle = '#555';

  if (w.slope) {
    // üî∫ slope wall (triangle)
    ctx.beginPath();

    const flipped = w.flip === true;

    if (w.slope === 'left') {
      if (!flipped) {
        // normal left slope
        ctx.moveTo(-w.w / 2,  w.h / 2);
        ctx.lineTo( w.w / 2,  w.h / 2);
        ctx.lineTo(-w.w / 2, -w.h / 2);
      } else {
        // flipped left slope (upside down)
        ctx.moveTo(-w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2, -w.h / 2);
        ctx.lineTo(-w.w / 2,  w.h / 2);
      }
    }

    else if (w.slope === 'right') {
      if (!flipped) {
        // normal right slope
        ctx.moveTo(-w.w / 2,  w.h / 2);
        ctx.lineTo( w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2,  w.h / 2);
      } else {
        // flipped right slope (upside down)
        ctx.moveTo(-w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2, -w.h / 2);
        ctx.lineTo( w.w / 2,  w.h / 2);
      }
    }

    ctx.closePath();
    ctx.fill();
  } else {
    // üß± normal wall
    ctx.fillRect(-w.w / 2, -w.h / 2, w.w, w.h);
  }

  ctx.restore();
}




    // =====================
    // Draw barriers (top-left based, rotated)
    // =====================
    for (const b of barriers) {
      const cx = b.x + b.w / 2;
      const cy = b.y + b.h / 2;
      const rot = (b.rotation || 0) * Math.PI / 180;
      const hpPct = b.hp / b.hpMax;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rot);

      // base
      ctx.fillStyle = '#333';
      ctx.fillRect(-b.w / 2, -b.h / 2, b.w, b.h);

      // HP fill (fills from top ‚Üí bottom)
      ctx.fillStyle = b.open ? '#a33' : '#3a7';
      ctx.fillRect(
       -b.w / 2,
       -b.h / 2,
       b.w,
       b.h * hpPct
      );

      // outline
      ctx.strokeStyle = '#555';
      ctx.strokeRect(-b.w / 2, -b.h / 2, b.w, b.h);

      ctx.restore();
    }

    for (const w of walls) {
      if (rectIntersect(player, w)) {
        player.x = player.prevX;
        player.y = player.prevY;
      }
    }

    // Interactables (dynamic labels for wall-buys showing ammo price)
    // Interactables (dynamic labels for wall-buys showing ammo price)
    // Interactables (dynamic labels + mystery box active state)
    for (const i of interacts) {

      // ‚≠ê MYSTERY BOX COLOR LOGIC
      if (i.type === 'box') {
        const box = i.ref; // reference to mysteryBoxes entry

        ctx.fillStyle = box && box.active
          ? '#ffcc00'   // ACTIVE mystery box
          : '#555555';  // INACTIVE mystery box
      }
      else {
        ctx.fillStyle =
          i.type === 'upgrade' ? '#c77dff' :
          i.type === 'perk'
            ? (perkColors[i.perk] || '#264653')
            : i.type === 'wall'
              ? '#2a9d8f'
              : '#aaa';
      }


      ctx.beginPath();
      ctx.arc(i.x, i.y, 12, 0, TWO_PI);
      ctx.fill();



      ctx.fillStyle = '#ddd';
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      let label = '';

      if (i.type === 'box') {
        const box = i.ref;
        label = box && box.active
          ? `Mystery Box (${i.cost})`
          : 'Inactive Mystery Box';
      }
      else {
        label = typeof i.label === 'function' ? i.label() : i.label;
      }

      if (i.type === 'wall') {
        const gunName = i.gunName; // ‚Üê map-based wall buys use gunName
        const owned = !!player.guns[gunName];
        const ammoCost = Math.floor(i.cost / 2);
        label = owned
          ? `Ammo for ${gunName} (${ammoCost})`
          : i.label;
      }
      ctx.fillText(label, i.x, i.y - 20);
      const d = Math.hypot(player.x - i.x, player.y - i.y);
      if (d < 60) {
        if (i.type !== 'box' || (i.ref && i.ref.active)) {
          ctx.fillStyle = '#bbb';
          ctx.fillText('Press E', i.x, i.y + 24);
        }
      }

    }

    doors.forEach(d => {
      if (d.open) return; // üö™ opened doors vanish

      ctx.save();
      ctx.translate(d.x, d.y);
      ctx.rotate((d.rotation || 0) * Math.PI / 180);

      ctx.fillStyle = '#7b5';
      ctx.fillRect(-d.w / 2, -d.h / 2, d.w, d.h);

      ctx.restore();
    });


    // Power-ups on floor
    for (const p of powerDrops) {
      ctx.fillStyle = powerColors[p.type];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, TWO_PI);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(p.type, p.x, p.y - 16);
    }

    // Bullets
    ctx.fillStyle = '#f5f5f5';
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, 2, 0, TWO_PI);
      ctx.fill();
    }

    // Zombies
    for (const z of zombies) {
      if (!z.alive) continue;
      ctx.fillStyle = '#8b0000';
      ctx.beginPath();
      ctx.arc(z.x, z.y, z.r, 0, TWO_PI);
      ctx.fill();
      ctx.fillStyle = '#222';
      ctx.fillRect(z.x-12, z.y-18, 24, 4);
      const pct = clamp(z.hp / z.hpMax, 0,1);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(z.x-12, z.y-18, 24*pct, 4);
    }

    // Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.fillStyle = '#4c8bf5';
    ctx.beginPath();
    ctx.arc(0,0,14,0,TWO_PI);
    ctx.fill();
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(20,0);
    ctx.stroke();
    ctx.restore();

    // Game over overlay
    if (!player.alive) {
      /* PERK WIPE */
      player.perks = { juggernog:false, speedCola:false, doubleTap:false, staminUp:false, quickRevive:false, quickReviveUsed:false };
      player.quickRevive.level = 0;
      player.quickRevive.cost = player.quickRevive.baseCost;
    }

if (player.downed) {
  ctx.save();

  // ‚úÖ FORCE SCREEN SPACE (ignore camera)
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  const cw = canvas.width;
  const ch = canvas.height;
  const cx = cw / 2;
  const cy = ch / 2;

  // ---------- Dark overlay ----------
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, cw, ch);

  // ---------- Center box ----------
  const boxW = 380;
  const boxH = 200;
  const bx = cx - boxW / 2;
  const by = cy - boxH / 2;

  ctx.fillStyle = '#111';
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 3;
  ctx.fillRect(bx, by, boxW, boxH);
  ctx.strokeRect(bx, by, boxW, boxH);

  // ---------- Text ----------
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Title
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 42px system-ui';
  ctx.fillText('REVIVING', cx, by + 50);

  // ---------- Timer number ----------
  const timeLeft = Math.max(0, player.reviveTimer);
  ctx.fillStyle = '#ffffff';
  ctx.font = '28px system-ui';
  ctx.fillText(
    timeLeft.toFixed(1),
    cx,
    by + 105
  );

  // ---------- Progress bar ----------
  const barW = 280;
  const barH = 18;
  const barX = cx - barW / 2;
  const barY = by + 140;

  const progress = clamp(
    timeLeft / player.reviveDuration,
    0,
    1
  );

  // Bar background
  ctx.fillStyle = '#333';
  ctx.fillRect(barX, barY, barW, barH);

  // Bar fill
  ctx.fillStyle = '#1abc9c';
  ctx.fillRect(barX, barY, barW * progress, barH);

  // Bar outline
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 2;
  ctx.strokeRect(barX, barY, barW, barH);

  ctx.restore();
}


///--------------------
    // Round transition banner (TOP, no dimming)

    ctx.restore(); // end camera

    // UI overlays (round banner, game over, revive)
    drawRoundBanner();
    drawWeaponHUD();
    drawPointsHUD();
    drawPerkIcons();
    drawPowerUpIcons();
    updateZombieUI();


  }

  function loop(t) {
    now = t;
    const dt = (t - lastTime) / 1000;
    lastTime = t;

    if (!gamePaused && (player.alive || player.downed)) {
      update(dt);
    }


    draw();

    if (gamePaused) {
      drawPauseOverlay();
    }

    requestAnimationFrame(loop);
  }

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    requestAnimationFrame(loop);
  
})();
</script>
</body>
</html>
